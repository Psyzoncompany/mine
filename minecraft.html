<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meu Craft üåç - Vaca 3D, Drops & Anima√ß√£o</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Courier New', Courier, monospace;
        }

        #vida-player {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ff4444;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            font-size: 24px;
            z-index: 100;
        }

        #damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 0, 0, 0);
            pointer-events: none;
            z-index: 99;
            transition: background 0.2s;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        #crosshair::before {
            top: 9px;
            left: 0;
            width: 20px;
            height: 2px;
        }

        #crosshair::after {
            top: 0;
            left: 9px;
            width: 2px;
            height: 20px;
        }

        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 5px;
        }

        .slot {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.3);
            border: 3px solid #666;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            position: relative;
            background-size: cover;
            cursor: pointer;
        }

        .slot .qty {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px #000;
            pointer-events: none;
        }

        .slot.empty {
            opacity: 0.4;
        }

        .slot.active {
            border-color: #FFF;
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        #menu,
        #inventory-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 10;
        }

        #inventory-menu {
            display: none;
            background: rgba(60, 60, 60, 0.95);
            border: 4px solid #1e1e1e;
            width: 500px;
            height: 450px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            border-radius: 4px;
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .inv-item {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #555;
            padding: 10px;
            text-align: center;
            border-radius: 4px;
            position: relative;
        }

        .inv-item .qty {
            position: absolute;
            bottom: 4px;
            right: 6px;
            font-weight: bold;
            color: #fff;
        }

        .inv-item .icon {
            font-size: 24px;
            display: block;
        }

        .inv-item .name {
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
        }

        button {
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            border-bottom: 4px solid #388E3C;
            margin: 10px;
        }

        button:active {
            transform: translateY(4px);
            border-bottom: 0;
        }

        button:disabled {
            background: #888;
            border-bottom: 4px solid #555;
            cursor: not-allowed;
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            line-height: 1.5;
        }

        #loading {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }

        #recursos {
            position: absolute;
            top: 40px;
            left: 10px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            font-size: 18px;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "./systems/": "./js/systems/",
                "./mobs/": "./js/mobs/",
                "./items/": "./js/items/"
            }
        }
    </script>
</head>

<body>

    <div id="loading">üåç Carregando mundo...</div>
    <div id="recursos">ü™µ Madeira: <span id="qtd-madeira">0</span></div>
    <div id="vida-player">‚ù§Ô∏è Life: <span id="player-hp">20</span></div>
    <div id="damage-flash"></div>
    <div id="crosshair"></div>

    <div id="hotbar">
        <div class="slot active" id="slot-0"><span class="qty"></span></div>
        <div class="slot" id="slot-1"><span class="qty"></span></div>
        <div class="slot" id="slot-2"><span class="qty"></span></div>
        <div class="slot" id="slot-3"><span class="qty"></span></div>
        <div class="slot" id="slot-4"><span class="qty"></span></div>
        <div class="slot" id="slot-5"><span class="qty"></span></div>
        <div class="slot" id="slot-6"><span class="qty"></span></div>
    </div>

    <div id="menu">
        <h1>üåç Meu Craft Infinito</h1>
        <button id="btn-play">‚ñ∂Ô∏è Jogar</button>
        <div class="instructions">
            üèÉ‚Äç‚ôÇÔ∏è <b>WASD</b>: Andar | <b>Espa√ßo</b>: Pular | <b>Mouse</b>: Olhar<br>
            ‚õèÔ∏è <b>Clique Esq</b>: Quebrar | üß± <b>Clique Dir</b>: Colocar<br>
            üéí <b>1 a 7 / Scroll</b>: Hotbar | üéí <b>E</b>: Invent√°rio / Crafting<br>
        </div>
    </div>

    <div id="inventory-menu">
        <h2>üéí Invent√°rio & Crafting</h2>
        <div class="inv-grid" id="inv-grid">
            <!-- Items via JS -->
        </div>
        <hr style="width:100%; border:1px solid #444;">
        <div style="margin-top: 15px; display:flex; gap: 20px; align-items:center;">
            <div>
                <p>üõ†Ô∏è <b>Crafting:</b> Aproveite sua madeira!</p>
                <button id="btn-craft-picareta">Criar Picareta (5 Madeira)</button>
                <button id="btn-craft-machado">Criar Machado (5 Madeira)</button>
            </div>
            <button id="btn-fechar-inv" style="background:#555; box-shadow: 0 4px 0 #333;">Fechar (E)</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
        import { SoundManager } from './systems/SoundManager.js';
        import { Ovelha } from './mobs/Ovelha.js';
        import { Vaca } from './mobs/Vaca.js';
        import { Porco } from './mobs/Porco.js';
        import { Cavaleiro } from './mobs/Cavaleiro.js';
        import { MonstroVazio } from './mobs/MonstroVazio.js';
        import { criarPicaretaElite } from './items/PicaretaElite.js';

        // üü¢ CONFIGURA√á√ïES B√ÅSICAS
        const cena = new THREE.Scene();
        cena.background = new THREE.Color(0x87CEEB);
        cena.fog = new THREE.Fog(0x87CEEB, 20, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderizador = new THREE.WebGLRenderer({ antialias: false });
        renderizador.setSize(window.innerWidth, window.innerHeight);
        renderizador.shadowMap.enabled = true;
        renderizador.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderizador.domElement);

        const controles = new PointerLockControls(camera, document.body);
        const menu = document.getElementById('menu');
        const inventoryMenu = document.getElementById('inventory-menu');

        const soundManager = new SoundManager();
        let playerHP = 20;

        // üéí SISTEMA DE INVENT√ÅRIO
        const STACK_MAX = 64;
        const itemDefs = {
            1: { id: 1, nome: "Grama", icon: "üü©", type: "block" },
            2: { id: 2, nome: "Terra", icon: "üü´", type: "block" },
            3: { id: 3, nome: "Pedra", icon: "‚¨ú", type: "block" },
            4: { id: 4, nome: "Madeira", icon: "ü™µ", type: "block" },
            5: { id: 5, nome: "Folhas", icon: "üçÉ", type: "block" }
        };

        let inventory = new Map(); // key: itemId, value: amount

        function addItem(itemId, amount = 1) {
            let current = inventory.get(itemId) || 0;
            if (current >= STACK_MAX) return false;
            inventory.set(itemId, Math.min(STACK_MAX, current + amount));
            renderUI();
            return true;
        }

        function removeItem(itemId, amount = 1) {
            let current = inventory.get(itemId) || 0;
            if (current < amount) return false;
            inventory.set(itemId, current - amount);
            renderUI();
            return true;
        }

        function getItemCount(itemId) { return inventory.get(itemId) || 0; }

        // üéí HOTBAR
        const HOTBAR_SIZE = 7;
        let hotbar = [
            { kind: "block", itemId: 1 },
            { kind: "block", itemId: 2 },
            { kind: "block", itemId: 3 },
            { kind: "block", itemId: 4 },
            { kind: "block", itemId: 5 },
            { kind: "tool", toolId: "picareta", unlocked: false },
            { kind: "tool", toolId: "machado", unlocked: false }
        ];
        let selectedHotbarIndex = 0;

        function renderUI() {
            // Atualiza Hotbar
            hotbar.forEach((slot, i) => {
                const el = document.getElementById(`slot-${i}`);
                el.classList.toggle('active', i === selectedHotbarIndex);
                const qtyEl = el.querySelector('.qty');

                if (slot.kind === "block") {
                    const count = getItemCount(slot.itemId);
                    qtyEl.innerText = count > 0 ? count : "";
                    el.classList.toggle('empty', count === 0);
                } else {
                    el.classList.toggle('empty', !slot.unlocked);
                    qtyEl.innerText = "";
                    // Visual das ferramentas facilitado
                    if (slot.toolId === "picareta") el.style.background = slot.unlocked ? "url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><path d=%22M20 80 L80 20 M70 10 L90 30 M80 20 L20 80%22 stroke=%22cyan%22 stroke-width=%228%22/><path d=%22M60 10 Q80 -10 100 10 Q110 30 90 40 L60 10%22 fill=%22silver%22/></svg>')" : "#333";
                    if (slot.toolId === "machado") el.style.background = slot.unlocked ? "url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><path d=%22M20 80 L80 20%22 stroke=%22brown%22 stroke-width=%228%22/><path d=%22M50 20 L80 50 L90 30 L60 10 Z%22 fill=%22silver%22/></svg>')" : "#333";
                }
            });

            // Atualiza Menu Invent√°rio
            const grid = document.getElementById('inv-grid');
            grid.innerHTML = "";
            Object.values(itemDefs).forEach(item => {
                const count = getItemCount(item.id);
                const div = document.createElement('div');
                div.className = "inv-item";
                div.innerHTML = `<span class="icon">${item.icon}</span><span class="name">${item.nome}</span><span class="qty">${count}</span>`;
                grid.appendChild(div);
            });

            document.getElementById('player-hp').innerText = playerHP;
            document.getElementById('btn-craft-picareta').disabled = getItemCount(4) < 5 || hotbar[5].unlocked;
            document.getElementById('btn-craft-machado').disabled = getItemCount(4) < 5 || hotbar[6].unlocked;

            atualizarMao();
        }

        window.addEventListener('playerDamage', (e) => {
            playerHP -= e.detail.amount;
            renderUI();
            const flash = document.getElementById('damage-flash');
            if (flash) {
                flash.style.background = 'rgba(255, 0, 0, 0.4)';
                setTimeout(() => flash.style.background = 'rgba(255, 0, 0, 0)', 200);
            }
            soundManager.playSound('hit');
            if (playerHP <= 0) {
                alert("Game Over! Voc√™ foi derrotado.");
                location.reload();
            }
        });

        document.getElementById('btn-play').addEventListener('click', () => {
            menu.style.display = 'none';
            controles.lock();
            if (soundManager.ctx.state === 'suspended') soundManager.ctx.resume();
        });

        document.getElementById('btn-fechar-inv').addEventListener('click', () => {
            inventoryMenu.style.display = 'none';
            controles.lock();
        });

        controles.addEventListener('unlock', () => {
            if (inventoryMenu.style.display !== 'flex') menu.style.display = 'flex';
        });

        document.getElementById('btn-craft-picareta').addEventListener('click', () => {
            if (removeItem(4, 5)) { hotbar[5].unlocked = true; renderUI(); }
        });
        document.getElementById('btn-craft-machado').addEventListener('click', () => {
            if (removeItem(4, 5)) { hotbar[6].unlocked = true; renderUI(); }
        });

        // üí° ILUMINA√á√ÉO
        cena.add(new THREE.AmbientLight(0xffffff, 0.6));
        const luzSol = new THREE.DirectionalLight(0xffffff, 0.8);
        luzSol.position.set(20, 40, 20); luzSol.castShadow = true;
        luzSol.shadow.camera.left = -30; luzSol.shadow.camera.right = 30; luzSol.shadow.camera.top = 30; luzSol.shadow.camera.bottom = -30;
        luzSol.shadow.camera.near = 0.5; luzSol.shadow.camera.far = 100; luzSol.shadow.mapSize.width = 1024; luzSol.shadow.mapSize.height = 1024; luzSol.shadow.bias = -0.001;
        cena.add(luzSol); cena.add(luzSol.target);

        // üé® TEXTURAS DOS BLOCOS & UI
        function gerarTextura(tipo, uiSlot) {
            const canvas = document.createElement('canvas'); canvas.width = 16; canvas.height = 16; const ctx = canvas.getContext('2d');
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    let cor = ''; const ruido = Math.random() * 30 - 15;
                    if (tipo === 'grama_topo') cor = `rgb(${40 + ruido}, ${150 + ruido}, ${40 + ruido})`;
                    else if (tipo === 'grama_lado') cor = y < 4 ? `rgb(${40 + ruido}, ${150 + ruido}, ${40 + ruido})` : `rgb(${100 + ruido}, ${70 + ruido}, ${40 + ruido})`;
                    else if (tipo === 'terra') cor = `rgb(${100 + ruido}, ${70 + ruido}, ${40 + ruido})`;
                    else if (tipo === 'pedra') cor = `rgb(${120 + ruido}, ${120 + ruido}, ${120 + ruido})`;
                    else if (tipo === 'madeira') { const c = (x % 4 === 0 || x % 5 === 0) ? 60 : 90; cor = `rgb(${c + ruido}, ${c / 1.5 + ruido}, ${c / 3 + ruido})`; }
                    else if (tipo === 'folhas') { if (Math.random() > 0.3) cor = `rgb(${20 + ruido}, ${100 + ruido}, ${20 + ruido})`; else { ctx.clearRect(x, y, 1, 1); continue; } }
                    ctx.fillStyle = cor; ctx.fillRect(x, y, 1, 1);
                }
            }
            if (uiSlot !== undefined) document.getElementById(`slot-${uiSlot}`).style.backgroundImage = `url(${canvas.toDataURL()})`;

            const textura = new THREE.CanvasTexture(canvas);
            textura.magFilter = THREE.NearestFilter; textura.minFilter = THREE.NearestFilter; textura.colorSpace = THREE.SRGBColorSpace; return textura;
        }

        function gerarTexturaQuebra(progresso) {
            const canvas = document.createElement('canvas'); canvas.width = 100; canvas.height = 100; const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 100, 100);
            ctx.strokeStyle = 'rgba(20, 20, 20, 0.9)';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Rachaduras profundas padr√£o Hytale
            const crackPaths = [
                "M52 18 L48 32 L56 48 L44 65 M15 45 L32 42 L48 55",
                "M25 25 L38 42 L18 68 M78 20 L62 42 L88 58 M40 80 L55 72",
                "M5 12 L28 22 M92 92 L68 78 M12 88 L45 72 M75 45 L95 40",
                "M50 2 L50 98 M2 50 L98 50 M18 18 L82 82 M82 18 L18 82",
                "M35 35 m-15 0 a 15 15 0 1 0 30 0 a 15 15 0 1 0 -30 0 M65 65 m-10 0 a 10 10 0 1 0 20 0 a 10 10 0 1 0 -20 0"
            ];

            const maxStage = Math.min(5, Math.floor(progresso * 6));

            for (let i = 0; i < maxStage; i++) {
                ctx.stroke(new Path2D(crackPaths[i]));
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = tex.minFilter = THREE.NearestFilter; return tex;
        }

        const matQuebra = new THREE.MeshBasicMaterial({ transparent: true, polygonOffset: true, polygonOffsetFactor: -1 });
        const meshQuebra = new THREE.Mesh(new THREE.BoxGeometry(1.01, 1.01, 1.01), matQuebra);
        meshQuebra.visible = false; cena.add(meshQuebra);

        const matTerra = new THREE.MeshLambertMaterial({ map: gerarTextura('terra', 2) });
        const matGramaTopo = new THREE.MeshLambertMaterial({ map: gerarTextura('grama_topo') });
        const matGramaLado = new THREE.MeshLambertMaterial({ map: gerarTextura('grama_lado', 1) });

        const materiais = {
            1: [matGramaLado, matGramaLado, matGramaTopo, matTerra, matGramaLado, matGramaLado],
            2: matTerra,
            3: new THREE.MeshLambertMaterial({ map: gerarTextura('pedra', 3) }),
            4: new THREE.MeshLambertMaterial({ map: gerarTextura('madeira', 4) }),
            5: new THREE.MeshLambertMaterial({ map: gerarTextura('folhas', 5), transparent: true, alphaTest: 0.5 })
        };

        // ‚úã SISTEMA DA M√ÉO
        const grupoMao = new THREE.Group();
        grupoMao.position.set(0.6, -0.4, -0.7);
        camera.add(grupoMao); cena.add(camera);

        const matMao = new THREE.MeshLambertMaterial({ color: 0xffccaa });
        const braco = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.6, 0.15), matMao);
        braco.position.set(0, -0.2, 0);
        braco.rotation.x = -Math.PI / 12; // Leve inclina√ß√£o para frente
        grupoMao.add(braco);

        let itemSegurado;

        function atualizarMao() {
            if (itemSegurado) grupoMao.remove(itemSegurado);
            const slot = hotbar[selectedHotbarIndex];

            if (slot.kind === "block") {
                if (getItemCount(slot.itemId) > 0) {
                    itemSegurado = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), materiais[slot.itemId]);
                    itemSegurado.position.set(0, 0.1, -0.3);
                } else itemSegurado = null;
            } else if (slot.kind === "tool" && slot.unlocked) {
                if (slot.toolId === "picareta") {
                    itemSegurado = criarPicaretaElite();
                    // üîÑ TWEAK: Picareta na vertical estilo Minecraft
                    // O bra√ßo invis√≠vel central do jogador segura a base
                    itemSegurado.rotation.x = -Math.PI / 4; // Bico ligeiramente pra frente
                    itemSegurado.position.set(0, 0.1, -0.2);
                } else {
                    // Machado gen√©rico
                    itemSegurado = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.6, 0.3), new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                    itemSegurado.rotation.x = -Math.PI / 4;
                    itemSegurado.position.set(0, 0.3, -0.2);
                }
            } else itemSegurado = null;

            if (itemSegurado) grupoMao.add(itemSegurado);
        }
        renderUI();

        let animandoMao = false; let progressoMao = 0; let bobTimer = 0; // Para animar andando



        let animais = [];
        const geometriaBloco = new THREE.BoxGeometry(1, 1, 1);

        // üî≤ CONTORNO DO BLOCO MIRADO
        const geoContorno = new THREE.EdgesGeometry(new THREE.BoxGeometry(1.005, 1.005, 1.005));
        const matContorno = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
        const contornoBloco = new THREE.LineSegments(geoContorno, matContorno);
        contornoBloco.visible = false; cena.add(contornoBloco);

        // üåç SISTEMA DE CHUNKS INFINITOS
        const mundo = new Map();
        const chunksGerados = new Set();
        const chunksVisuais = new Map();
        const TAMANHO_CHUNK = 16;
        const DISTANCIA_RENDER = 2;
        let chunkAtualX = -999, chunkAtualZ = -999;
        const noise = new ImprovedNoise();

        function obterIdChunk(cx, cz) { return `${cx},${cz}`; }

        function gerarArvore(x, y, z) {
            const altura = Math.floor(Math.random() * 3) + 4;
            for (let i = 0; i < altura; i++) { if (!mundo.has(`${x},${y + i},${z}`)) mundo.set(`${x},${y + i},${z}`, 4); }
            for (let fx = -2; fx <= 2; fx++) {
                for (let fz = -2; fz <= 2; fz++) {
                    for (let fy = altura - 2; fy <= altura + 1; fy++) {
                        const dist = Math.abs(fx) + Math.abs(fy - altura) + Math.abs(fz);
                        if (dist < 4 && !mundo.has(`${x + fx},${y + fy},${z + fz}`)) mundo.set(`${x + fx},${y + fy},${z + fz}`, 5);
                    }
                }
            }
        }

        function criarAnimal(x, y, z, cx, cz) {
            const tipos = ['porco', 'vaca', 'ovelha'];
            const sumChunks = Math.abs(cx) + Math.abs(cz);

            // Cavaleiro a cada 20 chunks
            const isKnight = sumChunks % 20 === 0 && Math.random() < 0.5;
            // Mob 1 (Monstro Vazio) a cada 25 chunks - Spawnamos 2
            const isMob1 = sumChunks > 0 && sumChunks % 25 === 0;

            if (isMob1) {
                animais.push(new MonstroVazio(cena, x, y, z, `${cx},${cz}`));
                animais.push(new MonstroVazio(cena, x + 1.2, y, z + 1.2, `${cx},${cz}`));
                return;
            }

            let animal;
            if (isKnight) {
                animal = new Cavaleiro(cena, x, y, z, `${cx},${cz}`);
            } else {
                const tipo = tipos[Math.floor(Math.random() * tipos.length)];
                if (tipo === 'ovelha') animal = new Ovelha(cena, x, y, z, `${cx},${cz}`);
                else if (tipo === 'vaca') animal = new Vaca(cena, x, y, z, `${cx},${cz}`);
                else animal = new Porco(cena, x, y, z, `${cx},${cz}`);
            }

            animais.push(animal);
        }

        function gerarDadosChunk(cx, cz) {
            const id = obterIdChunk(cx, cz); if (chunksGerados.has(id)) return; chunksGerados.add(id);
            for (let lx = 0; lx < TAMANHO_CHUNK; lx++) {
                for (let lz = 0; lz < TAMANHO_CHUNK; lz++) {
                    const x = cx * TAMANHO_CHUNK + lx; const z = cz * TAMANHO_CHUNK + lz;
                    let alt = Math.floor(noise.noise(x / 30, 0, z / 30) * 8);
                    for (let y = -15; y <= alt; y++) {
                        let buraco = noise.noise(x / 12, y / 12, z / 12);
                        if (y < alt - 2 && buraco > 0.4) continue;
                        let tipo = 3; if (y === alt) tipo = 1; else if (y > alt - 3) tipo = 2;
                        if (!mundo.has(`${x},${y},${z}`)) mundo.set(`${x},${y},${z}`, tipo);
                    }
                    if (Math.random() < 0.02 && mundo.get(`${x},${alt},${z}`) === 1) gerarArvore(x, alt + 1, z);
                }
            }
            if (Math.random() < 0.4) {
                const ax = cx * TAMANHO_CHUNK + Math.floor(Math.random() * TAMANHO_CHUNK);
                const az = cz * TAMANHO_CHUNK + Math.floor(Math.random() * TAMANHO_CHUNK);
                for (let y = 25; y >= -15; y--) { if (mundo.has(`${ax},${y},${az}`)) { criarAnimal(ax, y + 1.62, az, cx, cz); break; } }
            }
        }

        function construirChunkVisual(cx, cz) {
            const id = obterIdChunk(cx, cz); if (chunksVisuais.has(id)) return;
            const grupo = new THREE.Group(); const blocosChunk = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            for (let lx = 0; lx < TAMANHO_CHUNK; lx++) {
                for (let lz = 0; lz < TAMANHO_CHUNK; lz++) {
                    const x = cx * TAMANHO_CHUNK + lx; const z = cz * TAMANHO_CHUNK + lz;
                    for (let y = -15; y < 25; y++) {
                        const tipo = mundo.get(`${x},${y},${z}`);
                        if (tipo) {
                            const exposto = !mundo.has(`${x + 1},${y},${z}`) || !mundo.has(`${x - 1},${y},${z}`) || !mundo.has(`${x},${y + 1},${z}`) || !mundo.has(`${x},${y - 1},${z}`) || !mundo.has(`${x},${y},${z + 1}`) || !mundo.has(`${x},${y},${z - 1}`);
                            if (exposto) blocosChunk[tipo].push(new THREE.Vector3(x, y, z));
                        }
                    }
                }
            }
            for (let tipo in blocosChunk) {
                const pos = blocosChunk[tipo]; if (pos.length === 0) continue;
                const instancedMesh = new THREE.InstancedMesh(geometriaBloco, materiais[tipo], pos.length);
                const matriz = new THREE.Matrix4();
                pos.forEach((p, index) => { matriz.setPosition(p.x, p.y, p.z); instancedMesh.setMatrixAt(index, matriz); });
                instancedMesh.castShadow = true; instancedMesh.receiveShadow = true; grupo.add(instancedMesh);
            }
            cena.add(grupo); chunksVisuais.set(id, grupo);
        }

        function atualizarChunks() {
            const px = Math.floor(camera.position.x / TAMANHO_CHUNK); const pz = Math.floor(camera.position.z / TAMANHO_CHUNK);
            if (px !== chunkAtualX || pz !== chunkAtualZ || chunksVisuais.size === 0) {
                document.getElementById('loading').innerText = "Carregando √°rea..."; chunkAtualX = px; chunkAtualZ = pz;
                for (let cx = px - DISTANCIA_RENDER; cx <= px + DISTANCIA_RENDER; cx++) { for (let cz = pz - DISTANCIA_RENDER; cz <= pz + DISTANCIA_RENDER; cz++) { gerarDadosChunk(cx, cz); } }
                for (let cx = px - DISTANCIA_RENDER; cx <= px + DISTANCIA_RENDER; cx++) { for (let cz = pz - DISTANCIA_RENDER; cz <= pz + DISTANCIA_RENDER; cz++) { construirChunkVisual(cx, cz); } }
                for (const [id, grupo] of chunksVisuais.entries()) {
                    const [cx, cz] = id.split(',').map(Number);
                    if (Math.abs(cx - px) > DISTANCIA_RENDER || Math.abs(cz - pz) > DISTANCIA_RENDER) {
                        cena.remove(grupo); grupo.children.forEach(m => m.dispose()); chunksVisuais.delete(id);
                        animais = animais.filter(a => { if (a.chunkId === id) { cena.remove(a.mesh); return false; } return true; });
                    }
                }
                document.getElementById('loading').innerText = `Chunks ativos: ${chunksVisuais.size}`;
            }
        }

        function recriarChunkVisual(x, z) {
            const cx = Math.floor(x / TAMANHO_CHUNK); const cz = Math.floor(z / TAMANHO_CHUNK); const id = obterIdChunk(cx, cz);
            if (chunksVisuais.has(id)) { const grupo = chunksVisuais.get(id); cena.remove(grupo); grupo.children.forEach(m => m.dispose()); chunksVisuais.delete(id); construirChunkVisual(cx, cz); }
        }

        // üèÉ‚Äç‚ôÇÔ∏è CONTROLES
        camera.position.set(0, 20, 0);
        const teclas = { w: false, a: false, s: false, d: false, space: false };
        let velocidadeY = 0; let noChao = false;

        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyW') teclas.w = true; if (e.code === 'KeyS') teclas.s = true; if (e.code === 'KeyA') teclas.a = true; if (e.code === 'KeyD') teclas.d = true; if (e.code === 'Space') teclas.space = true;

            if (e.key >= '1' && e.key <= '7') {
                selectedHotbarIndex = parseInt(e.key) - 1;
                renderUI();
            }
            if (e.key.toLowerCase() === 'e') {
                if (inventoryMenu.style.display === 'flex') {
                    inventoryMenu.style.display = 'none';
                    controles.lock();
                } else {
                    inventoryMenu.style.display = 'flex';
                    menu.style.display = 'none';
                    controles.unlock();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW') teclas.w = false; if (e.code === 'KeyS') teclas.s = false; if (e.code === 'KeyA') teclas.a = false; if (e.code === 'KeyD') teclas.d = false; if (e.code === 'Space') teclas.space = false;
        });

        document.addEventListener('wheel', (e) => {
            if (!controles.isLocked) return;
            if (e.deltaY > 0) selectedHotbarIndex = (selectedHotbarIndex + 1) % HOTBAR_SIZE;
            else selectedHotbarIndex = (selectedHotbarIndex - 1 + HOTBAR_SIZE) % HOTBAR_SIZE;
            renderUI();
        });

        function checarColisao(x, y, z) {
            const w = 0.3; // Um pouco mais largo para no atravessar cantos
            const pos = [
                [x - w, y - 1.62, z - w], [x + w, y - 1.62, z - w], [x - w, y - 1.62, z + w], [x + w, y - 1.62, z + w], // P√©s
                [x - w, y - 0.8, z - w], [x + w, y - 0.8, z - w], [x - w, y - 0.8, z + w], [x + w, y - 0.8, z + w],    // Cintura
                [x - w, y + 0.1, z - w], [x + w, y + 0.1, z - w], [x - w, y + 0.1, z + w], [x + w, y + 0.1, z + w]      // Cabe√ßa
            ];
            return pos.some(p => mundo.has(`${Math.floor(p[0])},${Math.floor(p[1])},${Math.floor(p[2])}`));
        }

        // üì¶ SISTEMA DE DROPS (ITENS NO CH√ÉO)
        let itensDropados = [];
        const geoDrop = new THREE.BoxGeometry(0.25, 0.25, 0.25);
        function droparItem(x, y, z, tipo) {
            const mesh = new THREE.Mesh(geoDrop, materiais[tipo]);
            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            mesh.castShadow = true; cena.add(mesh);
            itensDropados.push({ mesh, tipo, vy: 0.2 }); // D√° um pulinho ao nascer
        }

        // üå´Ô∏è PART√çCULAS (DEBRIS)
        let particulasQuebra = [];
        const geoParticula = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        function criarParticulas(x, y, z, tipoBloco, qtde = 15) {
            let matBase = materiais[tipoBloco];
            const mat = Array.isArray(matBase) ? matBase[2] : (matBase || materiais[2]);

            for (let i = 0; i < qtde; i++) {
                const p = new THREE.Mesh(geoParticula, mat);
                p.position.set(x + Math.random(), y + Math.random(), z + Math.random());
                const angle = Math.random() * Math.PI * 2;
                const speed = 1.0 + Math.random() * 2;
                p.userData = {
                    vx: Math.cos(angle) * speed,
                    vy: 2 + Math.random() * 3,
                    vz: Math.sin(angle) * speed,
                    life: 0.6 + Math.random() * 0.6
                };
                cena.add(p);
                particulasQuebra.push(p);
            }
        }

        // ‚õèÔ∏è INTERA√á√ÉO
        const raycaster = new THREE.Raycaster(); const centroTela = new THREE.Vector2(0, 0);
        let quebrandoBloco = null;
        let tempoQuebrando = 0;
        const TEMPO_PARA_QUEBRAR = 1.3;

        document.addEventListener('mousedown', (e) => {
            if (!controles.isLocked) return;

            if (e.button === 0) { // Tentativa de quebrar
                raycaster.setFromCamera(centroTela, camera);
                const objetos = Array.from(chunksVisuais.values()).flatMap(g => g.children);
                const interseccoes = raycaster.intersectObjects(objetos);

                if (interseccoes.length > 0) {
                    const hit = interseccoes[0];
                    const pt = hit.point; const normal = hit.face.normal;
                    const hitX = Math.round(pt.x - normal.x * 0.5);
                    const hitY = Math.round(pt.y - normal.y * 0.5);
                    const hitZ = Math.round(pt.z - normal.z * 0.5);
                    quebrandoBloco = { x: hitX, y: hitY, z: hitZ };
                    tempoQuebrando = 0;
                } else {
                    // Tenta bater em animal
                    const animalIntersects = raycaster.intersectObjects(animais.map(a => a.mesh), true);
                    if (animalIntersects.length > 0) {
                        const meshHit = animalIntersects[0].object;
                        const animal = animais.find(a => {
                            let isChild = false;
                            a.mesh.traverse(child => { if (child === meshHit) isChild = true; });
                            return isChild;
                        });
                        if (animal) animal.sofrerDano(5, soundManager);
                        animandoMao = true; progressoMao = 0;
                    }
                }
            } else if (e.button === 2) { // Colocar
                const slot = hotbar[selectedHotbarIndex];
                if (slot.kind !== "block" || getItemCount(slot.itemId) === 0) return;

                raycaster.setFromCamera(centroTela, camera);
                const objetos = Array.from(chunksVisuais.values()).flatMap(g => g.children);
                const interseccoes = raycaster.intersectObjects(objetos);
                if (interseccoes.length > 0) {
                    const hit = interseccoes[0]; const pt = hit.point; const normal = hit.face.normal;
                    const nx = Math.round(normal.x); const ny = Math.round(normal.y); const nz = Math.round(normal.z);
                    const hitX = Math.round(pt.x - nx * 0.5); const hitY = Math.round(pt.y - ny * 0.5); const hitZ = Math.round(pt.z - nz * 0.5);
                    const placeX = hitX + nx; const placeY = hitY + ny; const placeZ = hitZ + nz;

                    // Bloqueia se colocar no jogador (dist < 1.0)
                    const distToPlayer = camera.position.distanceTo(new THREE.Vector3(placeX + 0.5, placeY + 0.5, placeZ + 0.5));
                    if (distToPlayer < 1.0) return;

                    if (!mundo.has(`${placeX},${placeY},${placeZ}`)) {
                        mundo.set(`${placeX},${placeY},${placeZ}`, slot.itemId);
                        soundManager.playSound('place');
                        removeItem(slot.itemId, 1);
                        recriarChunkVisual(placeX, placeZ);
                        // Vizinhos
                        if (placeX % TAMANHO_CHUNK === 0) recriarChunkVisual(placeX - 1, placeZ);
                        if (placeX % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(placeX + 1, placeZ);
                        if (placeZ % TAMANHO_CHUNK === 0) recriarChunkVisual(placeX, placeZ - 1);
                        if (placeZ % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(placeX, placeZ + 1);
                    }
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                quebrandoBloco = null;
                tempoQuebrando = 0;
                contornoBloco.scale.set(1, 1, 1);
            }
        });

        const relogio = new THREE.Clock();
        function animar() {
            requestAnimationFrame(animar);
            if (controles.isLocked) {
                atualizarChunks(); const delta = relogio.getDelta();

                luzSol.position.set(camera.position.x + 20, camera.position.y + 40, camera.position.z + 20); luzSol.target.position.copy(camera.position);

                raycaster.setFromCamera(centroTela, camera);
                const objs = Array.from(chunksVisuais.values()).flatMap(g => g.children);
                const mira = raycaster.intersectObjects(objs);
                if (mira.length > 0) {
                    const n = mira[0].face.normal;
                    contornoBloco.position.set(Math.round(mira[0].point.x - Math.round(n.x) * 0.5), Math.round(mira[0].point.y - Math.round(n.y) * 0.5), Math.round(mira[0].point.z - Math.round(n.z) * 0.5));
                    contornoBloco.visible = true;
                } else contornoBloco.visible = false;

                const velocidadeAndar = 5 * delta; const posAntiga = camera.position.clone();
                let moveZ = Number(teclas.w) - Number(teclas.s); let moveX = Number(teclas.a) - Number(teclas.d);
                let movendo = moveX !== 0 || moveZ !== 0;

                // ‚úã ANIMA√á√ÉO DA M√ÉO (Bobbing - Andando & Quebrando)
                if (animandoMao) {
                    progressoMao += delta * 15;
                    if (progressoMao > Math.PI) {
                        if (quebrandoBloco) progressoMao = 0; // Loop enquanto quebra
                        else { animandoMao = false; grupoMao.rotation.x = 0; }
                    }
                    else { grupoMao.rotation.x = -Math.sin(progressoMao) * 0.6; }
                }

                if (movendo && noChao) {
                    bobTimer += delta * 12; // Velocidade do balan√ßo
                    grupoMao.position.y = -0.4 + Math.abs(Math.sin(bobTimer)) * 0.05;
                    grupoMao.position.x = 0.6 + Math.sin(bobTimer / 2) * 0.05;
                } else {
                    bobTimer = 0;
                    grupoMao.position.y = THREE.MathUtils.lerp(grupoMao.position.y, -0.4, 0.1);
                    grupoMao.position.x = THREE.MathUtils.lerp(grupoMao.position.x, 0.6, 0.1);
                }

                // üì¶ F√çSICA DOS DROPS & COLETA
                for (let i = itensDropados.length - 1; i >= 0; i--) {
                    let item = itensDropados[i];
                    item.vy -= 1.0 * delta;
                    item.mesh.position.y += item.vy;
                    item.mesh.rotation.y += delta;

                    const blockY = Math.floor(item.mesh.position.y - 0.125);
                    if (mundo.has(`${Math.floor(item.mesh.position.x)},${blockY},${Math.floor(item.mesh.position.z)}`)) {
                        item.mesh.position.y = blockY + 1.125; item.vy = 0;
                    }

                    // Coleta universal com √≠m√£ de 2 blocos
                    const distToPlayer = camera.position.distanceTo(item.mesh.position);
                    if (distToPlayer < 2.0) {
                        if (addItem(item.tipo, 1)) {
                            soundManager.playSound('collect');
                            cena.remove(item.mesh); item.mesh.geometry.dispose();
                            itensDropados.splice(i, 1);
                        }
                    }
                }

                // üå´Ô∏è ATUALIZA PART√çCULAS
                for (let i = particulasQuebra.length - 1; i >= 0; i--) {
                    let p = particulasQuebra[i];
                    p.position.x += p.userData.vx * delta;
                    p.position.y += p.userData.vy * delta;
                    p.position.z += p.userData.vz * delta;
                    p.userData.vy -= 15 * delta; // Gravidade part√≠culas
                    p.rotation.x += delta * 15;
                    p.rotation.y += delta * 15;
                    p.userData.life -= delta * 2;
                    p.scale.setScalar(Math.max(0, p.userData.life));
                    if (p.userData.life <= 0) {
                        cena.remove(p);
                        particulasQuebra.splice(i, 1);
                    }
                }

                // ‚õèÔ∏è L√ìGICA DE QUEBRA GRADUAL
                if (quebrandoBloco) {
                    tempoQuebrando += delta;
                    animandoMao = true;
                    progressoMao += delta * 5;
                    const prog = tempoQuebrando / TEMPO_PARA_QUEBRAR;
                    const tipoBlocoQuebrando = mundo.get(`${quebrandoBloco.x},${quebrandoBloco.y},${quebrandoBloco.z}`);

                    // Mostra as rachaduras com efeito de Shake e Redu√ß√£o visual (ilus√£o √≥ptica nas texturas adjacentes)
                    meshQuebra.visible = true;
                    const shakeInt = prog * 0.05;
                    meshQuebra.position.set(
                        quebrandoBloco.x + (Math.random() - 0.5) * shakeInt,
                        quebrandoBloco.y + (Math.random() - 0.5) * shakeInt,
                        quebrandoBloco.z + (Math.random() - 0.5) * shakeInt
                    );

                    if (Math.floor(tempoQuebrando * 10) % 2 === 0) {
                        matQuebra.map = gerarTexturaQuebra(prog);
                        matQuebra.needsUpdate = true;
                    }

                    // Tweak org√¢nico na "hitbox" selecionada
                    const scale = 1.0 + Math.sin(tempoQuebrando * 20) * 0.03;
                    contornoBloco.scale.set(scale, scale, scale);

                    // Solta pequenas part√≠culas durante a escava√ß√£o
                    if (Math.random() < 0.2 && tipoBlocoQuebrando) {
                        criarParticulas(quebrandoBloco.x, quebrandoBloco.y, quebrandoBloco.z, tipoBlocoQuebrando, 1);
                    }

                    if (tempoQuebrando >= TEMPO_PARA_QUEBRAR) {
                        const { x, y, z } = quebrandoBloco;
                        if (tipoBlocoQuebrando) {
                            criarParticulas(x, y, z, tipoBlocoQuebrando, 20); // BOOM de detritos!
                            droparItem(x, y, z, tipoBlocoQuebrando);
                            soundManager.playSound('pop');
                            mundo.delete(`${x},${y},${z}`);
                            recriarChunkVisual(x, z);
                            if (x % TAMANHO_CHUNK === 0) recriarChunkVisual(x - 1, z); if (x % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(x + 1, z);
                            if (z % TAMANHO_CHUNK === 0) recriarChunkVisual(x, z - 1); if (z % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(x, z + 1);
                        }
                        quebrandoBloco = null;
                        tempoQuebrando = 0;
                        contornoBloco.scale.set(1, 1, 1);
                        meshQuebra.visible = false;
                    }
                } else {
                    meshQuebra.visible = false;
                }

                // üêÑ IA ANIMAIS
                animais.forEach(a => a.update(delta, mundo, camera));

                const direcao = new THREE.Vector3(); camera.getWorldDirection(direcao); direcao.y = 0; direcao.normalize();
                const lado = new THREE.Vector3(); lado.crossVectors(camera.up, direcao).normalize();

                if (movendo) {
                    const moveDir = new THREE.Vector2(moveX, moveZ).normalize();
                    const velX = (lado.x * moveDir.x + direcao.x * moveDir.y) * velocidadeAndar;
                    const velZ = (lado.z * moveDir.x + direcao.z * moveDir.y) * velocidadeAndar;

                    camera.position.x += velX;
                    if (checarColisao(camera.position.x, posAntiga.y, posAntiga.z)) {
                        camera.position.x = posAntiga.x;
                        if (noChao && !checarColisao(camera.position.x + velX, posAntiga.y + 1.1, posAntiga.z)) { velocidadeY = 0.2; camera.position.y += 0.1; noChao = false; }
                    }

                    camera.position.z += velZ;
                    if (checarColisao(camera.position.x, posAntiga.y, camera.position.z)) {
                        camera.position.z = posAntiga.z;
                        if (noChao && !checarColisao(camera.position.x, posAntiga.y + 1.1, posAntiga.z + velZ)) { velocidadeY = 0.2; camera.position.y += 0.1; noChao = false; }
                    }
                }

                if (teclas.space && noChao) { velocidadeY = 0.15; noChao = false; soundManager.playSound('jump'); }
                velocidadeY -= 0.5 * delta; camera.position.y += velocidadeY;

                if (checarColisao(camera.position.x, camera.position.y, camera.position.z)) { camera.position.y = posAntiga.y; velocidadeY = 0; noChao = true; } else noChao = false;
                if (camera.position.y < -30) { camera.position.set(camera.position.x, 20, camera.position.z); velocidadeY = 0; }
            } else relogio.getDelta();

            renderizador.render(cena, camera);
        }

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderizador.setSize(window.innerWidth, window.innerHeight); });
        atualizarChunks(); animar();
    </script>
</body>

</html>