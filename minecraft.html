<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meu Craft üåç - Vaca 3D, Drops & Anima√ß√£o</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Courier New', Courier, monospace; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255,255,255,0.8); }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }

        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 5px;
        }
        .slot {
            width: 50px; height: 50px; border: 3px solid #555; display: flex; align-items: flex-end; justify-content: flex-end;
            color: white; font-weight: bold; font-size: 14px; padding: 2px; box-sizing: border-box; box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
            background-size: cover; background-position: center; image-rendering: pixelated; /* üßä Texturas ficam pixeladas na UI */
        }
        .slot.active { border-color: #FFF; transform: scale(1.1); }

        /* Ferramentas (Desbloque√°veis) */
        #slot-6, #slot-7 { background-color: #444; display: none; }

        #menu, #crafting-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; z-index: 10;
        }
        #crafting-menu { display: none; background: rgba(139, 69, 19, 0.9); border: 10px solid #5C4033; width: 400px; height: 300px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        
        button {
            padding: 15px 30px; font-size: 20px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 5px; border-bottom: 4px solid #388E3C; margin: 10px;
        }
        button:active { transform: translateY(4px); border-bottom: 0; }
        button:disabled { background: #888; border-bottom: 4px solid #555; cursor: not-allowed; }
        .instructions { margin-top: 20px; text-align: center; line-height: 1.5; }
        
        #loading { position: absolute; top: 10px; left: 10px; color: white; font-weight: bold; text-shadow: 1px 1px 0 #000; }
        #recursos { position: absolute; top: 40px; left: 10px; color: white; font-weight: bold; text-shadow: 1px 1px 0 #000; font-size: 18px;}
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">üåç Carregando mundo...</div>
    <div id="recursos">ü™µ Madeira: <span id="qtd-madeira">0</span></div>
    <div id="crosshair"></div>
    
    <div id="hotbar">
        <div class="slot active" id="slot-1">1</div>
        <div class="slot" id="slot-2">2</div>
        <div class="slot" id="slot-3">3</div>
        <div class="slot" id="slot-4">4</div>
        <div class="slot" id="slot-5">5</div>
        <div class="slot" id="slot-6" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><path d=%22M20 80 L80 20 M70 10 L90 30 M80 20 L20 80%22 stroke=%22brown%22 stroke-width=%228%22/><path d=%22M60 10 Q80 -10 100 10 Q110 30 90 40 L60 10%22 fill=%22silver%22 stroke=%22#555%22 stroke-width=%222%22/></svg>');">6</div>
        <div class="slot" id="slot-7" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><path d=%22M20 80 L80 20%22 stroke=%22brown%22 stroke-width=%228%22/><path d=%22M50 20 L80 50 L90 30 L60 10 Z%22 fill=%22silver%22 stroke=%22#555%22 stroke-width=%222%22/></svg>');">7</div>
    </div>

    <div id="menu">
        <h1>üåç Meu Craft Infinito</h1>
        <button id="btn-play">‚ñ∂Ô∏è Jogar</button>
        <div class="instructions">
            üèÉ‚Äç‚ôÇÔ∏è <b>WASD</b>: Andar | <b>Espa√ßo</b>: Pular<br>
            ‚õèÔ∏è <b>Clique Esq</b>: Quebrar | üß± <b>Clique Dir</b>: Colocar<br>
            üéí <b>1 a 7</b>: Selecionar Bloco/Ferramenta<br>
            üõ†Ô∏è <b>E</b>: Abrir Crafting
        </div>
    </div>

    <div id="crafting-menu">
        <h2>üõ†Ô∏è Mesa de Crafting</h2>
        <p>ü™µ Madeira dispon√≠vel: <span id="craft-madeira">0</span></p>
        <button id="btn-craft-picareta">Criar Picareta (5 Madeira)</button>
        <button id="btn-craft-machado">Criar Machado (5 Madeira)</button>
        <button id="btn-fechar-craft">Fechar (E)</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';

        // üü¢ CONFIGURA√á√ïES B√ÅSICAS
        const cena = new THREE.Scene();
        cena.background = new THREE.Color(0x87CEEB); 
        cena.fog = new THREE.Fog(0x87CEEB, 20, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderizador = new THREE.WebGLRenderer({ antialias: false });
        renderizador.setSize(window.innerWidth, window.innerHeight);
        renderizador.shadowMap.enabled = true;
        renderizador.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderizador.domElement);

        const controles = new PointerLockControls(camera, document.body);
        const menu = document.getElementById('menu');
        const craftingMenu = document.getElementById('crafting-menu');
        
        let inventario = { madeira: 0, picareta: false, machado: false };
        let blocoSelecionado = 1; 

        function atualizarUI() {
            document.getElementById('qtd-madeira').innerText = inventario.madeira;
            document.getElementById('craft-madeira').innerText = inventario.madeira;
            document.getElementById('btn-craft-picareta').disabled = inventario.madeira < 5 || inventario.picareta;
            document.getElementById('btn-craft-machado').disabled = inventario.madeira < 5 || inventario.machado;
        }

        document.getElementById('btn-play').addEventListener('click', () => { menu.style.display = 'none'; controles.lock(); });
        document.getElementById('btn-fechar-craft').addEventListener('click', () => { craftingMenu.style.display = 'none'; controles.lock(); });
        controles.addEventListener('unlock', () => { if (craftingMenu.style.display !== 'flex') menu.style.display = 'flex'; });

        document.getElementById('btn-craft-picareta').addEventListener('click', () => {
            if(inventario.madeira >= 5) { inventario.madeira -= 5; inventario.picareta = true; document.getElementById('slot-6').style.display = 'flex'; atualizarUI(); }
        });
        document.getElementById('btn-craft-machado').addEventListener('click', () => {
            if(inventario.madeira >= 5) { inventario.madeira -= 5; inventario.machado = true; document.getElementById('slot-7').style.display = 'flex'; atualizarUI(); }
        });

        // üí° ILUMINA√á√ÉO
        cena.add(new THREE.AmbientLight(0xffffff, 0.6));
        const luzSol = new THREE.DirectionalLight(0xffffff, 0.8);
        luzSol.position.set(20, 40, 20); luzSol.castShadow = true;
        luzSol.shadow.camera.left = -30; luzSol.shadow.camera.right = 30; luzSol.shadow.camera.top = 30; luzSol.shadow.camera.bottom = -30;
        luzSol.shadow.camera.near = 0.5; luzSol.shadow.camera.far = 100; luzSol.shadow.mapSize.width = 1024; luzSol.shadow.mapSize.height = 1024; luzSol.shadow.bias = -0.001;
        cena.add(luzSol); cena.add(luzSol.target);

        // üé® TEXTURAS DOS BLOCOS & UI
        function gerarTextura(tipo, uiSlot) {
            const canvas = document.createElement('canvas'); canvas.width = 16; canvas.height = 16; const ctx = canvas.getContext('2d');
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    let cor = ''; const ruido = Math.random() * 30 - 15; 
                    if (tipo === 'grama_topo') cor = `rgb(${40+ruido}, ${150+ruido}, ${40+ruido})`;
                    else if (tipo === 'grama_lado') cor = y < 4 ? `rgb(${40+ruido}, ${150+ruido}, ${40+ruido})` : `rgb(${100+ruido}, ${70+ruido}, ${40+ruido})`;
                    else if (tipo === 'terra') cor = `rgb(${100+ruido}, ${70+ruido}, ${40+ruido})`;
                    else if (tipo === 'pedra') cor = `rgb(${120+ruido}, ${120+ruido}, ${120+ruido})`;
                    else if (tipo === 'madeira') { const c = (x % 4 === 0 || x % 5 === 0) ? 60 : 90; cor = `rgb(${c+ruido}, ${c/1.5+ruido}, ${c/3+ruido})`; } 
                    else if (tipo === 'folhas') { if (Math.random() > 0.3) cor = `rgb(${20+ruido}, ${100+ruido}, ${20+ruido})`; else { ctx.clearRect(x, y, 1, 1); continue; } }
                    ctx.fillStyle = cor; ctx.fillRect(x, y, 1, 1);
                }
            }
            if (uiSlot) document.getElementById(`slot-${uiSlot}`).style.backgroundImage = `url(${canvas.toDataURL()})`; // üì¶ Coloca no Hotbar!
            
            const textura = new THREE.CanvasTexture(canvas);
            textura.magFilter = THREE.NearestFilter; textura.minFilter = THREE.NearestFilter; textura.colorSpace = THREE.SRGBColorSpace; return textura;
        }

        const matTerra = new THREE.MeshLambertMaterial({ map: gerarTextura('terra', 2) });
        const matGramaTopo = new THREE.MeshLambertMaterial({ map: gerarTextura('grama_topo') });
        const matGramaLado = new THREE.MeshLambertMaterial({ map: gerarTextura('grama_lado', 1) });
        
        const materiais = {
            1: [matGramaLado, matGramaLado, matGramaTopo, matTerra, matGramaLado, matGramaLado], 
            2: matTerra,
            3: new THREE.MeshLambertMaterial({ map: gerarTextura('pedra', 3) }),
            4: new THREE.MeshLambertMaterial({ map: gerarTextura('madeira', 4) }),
            5: new THREE.MeshLambertMaterial({ map: gerarTextura('folhas', 5), transparent: true, alphaTest: 0.5 }) 
        };

        // ‚úã SISTEMA DA M√ÉO
        const grupoMao = new THREE.Group();
        grupoMao.position.set(0.6, -0.4, -0.7);
        camera.add(grupoMao); cena.add(camera);

        const matMao = new THREE.MeshLambertMaterial({ color: 0xffccaa });
        const braco = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), matMao);
        braco.position.set(0, -0.3, 0); braco.rotation.x = -Math.PI / 6;
        grupoMao.add(braco);

        let itemSegurado; 
        function atualizarMao() {
            if(itemSegurado) grupoMao.remove(itemSegurado);
            if (blocoSelecionado <= 5) {
                itemSegurado = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), materiais[blocoSelecionado]);
                itemSegurado.position.set(0, 0.2, -0.2);
            } else {
                const corMat = blocoSelecionado === 6 ? 0x888888 : 0x8B4513; 
                itemSegurado = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.6, 0.4), new THREE.MeshLambertMaterial({color: corMat}));
                itemSegurado.position.set(0, 0.3, -0.2);
            }
            grupoMao.add(itemSegurado);
        }
        atualizarMao();

        let animandoMao = false; let progressoMao = 0; let bobTimer = 0; // Para animar andando

        // üêÑ VACA 3D DETALHADA
        function criarTexturaVaca(desenhar) {
            const canvas = document.createElement('canvas'); canvas.width = 16; canvas.height = 16;
            const ctx = canvas.getContext('2d'); desenhar(ctx);
            const textura = new THREE.CanvasTexture(canvas); textura.magFilter = THREE.NearestFilter; textura.minFilter = THREE.NearestFilter; return textura;
        }

        const texCorpoVaca = criarTexturaVaca(ctx => { ctx.fillStyle = '#f4f4f4'; ctx.fillRect(0,0,16,16); ctx.fillStyle = '#1c1c1c'; ctx.fillRect(2,2,5,6); ctx.fillRect(10,8,6,8); ctx.fillRect(0,12,4,4); ctx.fillRect(12,0,4,3); });
        const texCabecaVaca = criarTexturaVaca(ctx => { ctx.fillStyle = '#f4f4f4'; ctx.fillRect(0,0,16,16); ctx.fillStyle = '#1c1c1c'; ctx.fillRect(0,0,8,6); ctx.fillRect(8,10,8,6); });
        const texPernaVaca = criarTexturaVaca(ctx => { ctx.fillStyle = '#f4f4f4'; ctx.fillRect(0,0,16,16); ctx.fillStyle = '#1c1c1c'; ctx.fillRect(0,0,6,8); ctx.fillStyle = '#333333'; ctx.fillRect(0,12,16,4); });
        const texFocinhoVaca = criarTexturaVaca(ctx => { ctx.fillStyle = '#d1a3a3'; ctx.fillRect(0,0,16,16); ctx.fillStyle = '#4a3535'; ctx.fillRect(2,4,4,6); ctx.fillRect(10,4,4,6); });
        const texTetaVaca = criarTexturaVaca(ctx => { ctx.fillStyle = '#e8a5b0'; ctx.fillRect(0,0,16,16); ctx.fillStyle = '#d68a97'; ctx.fillRect(2,2,4,4); ctx.fillRect(10,2,4,4); ctx.fillRect(2,10,4,4); ctx.fillRect(10,10,4,4); });

        const matCorpoV = new THREE.MeshStandardMaterial({ map: texCorpoVaca }); const matCabecaV = new THREE.MeshStandardMaterial({ map: texCabecaVaca });
        const matPernaV = new THREE.MeshStandardMaterial({ map: texPernaVaca }); const matRosaV = new THREE.MeshStandardMaterial({ color: 0xd1a3a3 });
        const matRosaClaroV = new THREE.MeshStandardMaterial({ color: 0xe8a5b0 }); const matChifreV = new THREE.MeshStandardMaterial({ color: 0xdcdcdc });
        const matOlhoPV = new THREE.MeshStandardMaterial({ color: 0x0f0f0f }); const matOlhoBV = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const matsFocinhoV = [matRosaV, matRosaV, matRosaV, matRosaV, new THREE.MeshStandardMaterial({ map: texFocinhoVaca }), matRosaV];
        const matsTetaV = [matRosaClaroV, matRosaClaroV, matRosaClaroV, new THREE.MeshStandardMaterial({ map: texTetaVaca }), matRosaClaroV, matRosaClaroV];

        function criarVacaDetalhada() {
            const vaca = new THREE.Group(); const s = 0.4;
            const corpo = new THREE.Mesh(new THREE.BoxGeometry(1.6*s, 1.4*s, 2.6*s), matCorpoV); corpo.position.y = 1.7*s; corpo.castShadow = true; vaca.add(corpo);
            const teta = new THREE.Mesh(new THREE.BoxGeometry(0.8*s, 0.4*s, 1.0*s), matsTetaV); teta.position.set(0, 0.9*s, 0.2*s); teta.castShadow = true; vaca.add(teta);
            const cabeca = new THREE.Mesh(new THREE.BoxGeometry(1.2*s, 1.2*s, 1.0*s), matCabecaV); cabeca.position.set(0, 2.5*s, 1.5*s); cabeca.castShadow = true; vaca.add(cabeca);
            const focinho = new THREE.Mesh(new THREE.BoxGeometry(1.0*s, 0.6*s, 0.4*s), matsFocinhoV); focinho.position.set(0, 2.2*s, 2.2*s); focinho.castShadow = true; vaca.add(focinho);
            const chifreEsq = new THREE.Mesh(new THREE.BoxGeometry(0.2*s, 0.6*s, 0.2*s), matChifreV); chifreEsq.position.set(0.5*s, 3.3*s, 1.3*s); vaca.add(chifreEsq);
            const chifreDir = new THREE.Mesh(new THREE.BoxGeometry(0.2*s, 0.6*s, 0.2*s), matChifreV); chifreDir.position.set(-0.5*s, 3.3*s, 1.3*s); vaca.add(chifreDir);
            const pernas = []; const posPernas = [[-0.5*s, 0.6*s, 0.9*s], [0.5*s, 0.6*s, 0.9*s], [-0.5*s, 0.6*s, -0.9*s], [0.5*s, 0.6*s, -0.9*s]];
            posPernas.forEach(pos => { const perna = new THREE.Mesh(new THREE.BoxGeometry(0.6*s, 1.2*s, 0.6*s), matPernaV); perna.position.set(pos[0], pos[1], pos[2]); perna.castShadow = true; vaca.add(perna); pernas.push(perna); });
            const olhoEsqP = new THREE.Mesh(new THREE.BoxGeometry(0.15*s, 0.15*s, 0.05*s), matOlhoPV); olhoEsqP.position.set(0.4*s, 2.7*s, 2.01*s); vaca.add(olhoEsqP);
            const olhoEsqB = new THREE.Mesh(new THREE.BoxGeometry(0.05*s, 0.15*s, 0.06*s), matOlhoBV); olhoEsqB.position.set(0.45*s, 2.7*s, 2.01*s); vaca.add(olhoEsqB);
            const olhoDirP = new THREE.Mesh(new THREE.BoxGeometry(0.15*s, 0.15*s, 0.05*s), matOlhoPV); olhoDirP.position.set(-0.4*s, 2.7*s, 2.01*s); vaca.add(olhoDirP);
            const olhoDirB = new THREE.Mesh(new THREE.BoxGeometry(0.05*s, 0.15*s, 0.06*s), matOlhoBV); olhoDirB.position.set(-0.35*s, 2.7*s, 2.01*s); vaca.add(olhoDirB);
            return { grupo: vaca, pernas: pernas };
        }

        // üêë OVELHA 3D
        function criarOvelhaDetalhada() {
            const ovelha = new THREE.Group(); const s = 0.4;
            const matLa = new THREE.MeshLambertMaterial({ color: 0xeeeeee }); const matPele = new THREE.MeshLambertMaterial({ color: 0xd8b0a0 });
            const matPerna = new THREE.MeshLambertMaterial({ color: 0x333333 }); const matOlho = new THREE.MeshLambertMaterial({ color: 0x0f0f0f });
            const matBrancoOlho = new THREE.MeshLambertMaterial({ color: 0xffffff }); const matFocinho = new THREE.MeshLambertMaterial({ color: 0xe57b89 });
            const corpo = new THREE.Mesh(new THREE.BoxGeometry(1.6*s, 1.6*s, 2.4*s), matLa); corpo.position.y = 1.6*s; corpo.castShadow = true; ovelha.add(corpo);
            const cabeca = new THREE.Mesh(new THREE.BoxGeometry(1.2*s, 1.2*s, 1.2*s), matPele); cabeca.position.set(0, 2.0*s, 1.6*s); cabeca.castShadow = true; ovelha.add(cabeca);
            const laCabeca = new THREE.Mesh(new THREE.BoxGeometry(1.3*s, 0.4*s, 1.3*s), matLa); laCabeca.position.set(0, 2.6*s, 1.6*s); laCabeca.castShadow = true; ovelha.add(laCabeca);
            const pernas = []; const posPernas = [[-0.4*s, 0.6*s, 0.8*s], [0.4*s, 0.6*s, 0.8*s], [-0.4*s, 0.6*s, -0.8*s], [0.4*s, 0.6*s, -0.8*s]];
            posPernas.forEach(pos => { const perna = new THREE.Mesh(new THREE.BoxGeometry(0.6*s, 1.2*s, 0.6*s), matPerna); perna.position.set(pos[0], pos[1], pos[2]); perna.castShadow = true; ovelha.add(perna); pernas.push(perna); });
            const olhoEsqP = new THREE.Mesh(new THREE.BoxGeometry(0.15*s, 0.15*s, 0.05*s), matOlho); olhoEsqP.position.set(0.35*s, 2.2*s, 2.21*s); ovelha.add(olhoEsqP);
            const olhoEsqB = new THREE.Mesh(new THREE.BoxGeometry(0.05*s, 0.15*s, 0.06*s), matBrancoOlho); olhoEsqB.position.set(0.4*s, 2.2*s, 2.21*s); ovelha.add(olhoEsqB);
            const olhoDirP = new THREE.Mesh(new THREE.BoxGeometry(0.15*s, 0.15*s, 0.05*s), matOlho); olhoDirP.position.set(-0.35*s, 2.2*s, 2.21*s); ovelha.add(olhoDirP);
            const olhoDirB = new THREE.Mesh(new THREE.BoxGeometry(0.05*s, 0.15*s, 0.06*s), matBrancoOlho); olhoDirB.position.set(-0.3*s, 2.2*s, 2.21*s); ovelha.add(olhoDirB);
            const focinho = new THREE.Mesh(new THREE.BoxGeometry(0.3*s, 0.2*s, 0.05*s), matFocinho); focinho.position.set(0, 1.9*s, 2.21*s); ovelha.add(focinho);
            return { grupo: ovelha, pernas: pernas };
        }

        // üê∑ PORCO (GEN√âRICO)
        function criarTexturaPorco() {
            const canvas = document.createElement('canvas'); canvas.width = 16; canvas.height = 16; const ctx = canvas.getContext('2d');
            for (let x = 0; x < 16; x++) { for (let y = 0; y < 16; y++) { const r = Math.random() * 20 - 10; ctx.fillStyle = `rgb(${255+r}, ${182+r}, ${193+r})`; ctx.fillRect(x, y, 1, 1); } }
            const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter; tex.minFilter = THREE.NearestFilter; return tex;
        }
        const matPorco = new THREE.MeshLambertMaterial({ map: criarTexturaPorco() });

        function criarPorco() {
            const grupo = new THREE.Group();
            const corpo = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.9), matPorco); corpo.position.y = 0.55; corpo.castShadow = true; grupo.add(corpo);
            const cabeca = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), matPorco); cabeca.position.set(0, 0.7, 0.5); cabeca.castShadow = true; grupo.add(cabeca);
            const pernas = []; const pos = [[-0.2, 0.15, 0.3], [0.2, 0.15, 0.3], [-0.2, 0.15, -0.3], [0.2, 0.15, -0.3]];
            pos.forEach(p => { const perna = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.2), matPorco); perna.position.set(p[0], p[1], p[2]); perna.castShadow = true; grupo.add(perna); pernas.push(perna); });
            return { grupo, pernas };
        }
        
        let animais = [];
        const geometriaBloco = new THREE.BoxGeometry(1, 1, 1);

        // üî≤ CONTORNO DO BLOCO MIRADO
        const geoContorno = new THREE.EdgesGeometry(new THREE.BoxGeometry(1.005, 1.005, 1.005));
        const matContorno = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
        const contornoBloco = new THREE.LineSegments(geoContorno, matContorno);
        contornoBloco.visible = false; cena.add(contornoBloco);

        // üåç SISTEMA DE CHUNKS INFINITOS
        const mundo = new Map();
        const chunksGerados = new Set();
        const chunksVisuais = new Map();
        const TAMANHO_CHUNK = 16;
        const DISTANCIA_RENDER = 2;
        let chunkAtualX = -999, chunkAtualZ = -999;
        const noise = new ImprovedNoise();

        function obterIdChunk(cx, cz) { return `${cx},${cz}`; }

        function gerarArvore(x, y, z) {
            const altura = Math.floor(Math.random() * 3) + 4;
            for (let i = 0; i < altura; i++) { if(!mundo.has(`${x},${y+i},${z}`)) mundo.set(`${x},${y+i},${z}`, 4); }
            for (let fx = -2; fx <= 2; fx++) {
                for (let fz = -2; fz <= 2; fz++) {
                    for (let fy = altura - 2; fy <= altura + 1; fy++) {
                        const dist = Math.abs(fx) + Math.abs(fy - altura) + Math.abs(fz);
                        if (dist < 4 && !mundo.has(`${x+fx},${y+fy},${z+fz}`)) mundo.set(`${x+fx},${y+fy},${z+fz}`, 5);
                    }
                }
            }
        }

        function criarAnimal(x, y, z, cx, cz) {
            const tipos = ['porco', 'vaca', 'ovelha'];
            const tipo = tipos[Math.floor(Math.random() * tipos.length)];
            let modelo;
            if (tipo === 'ovelha') modelo = criarOvelhaDetalhada();
            else if (tipo === 'vaca') modelo = criarVacaDetalhada();
            else modelo = criarPorco();

            modelo.grupo.position.set(x, y, z); cena.add(modelo.grupo);
            animais.push({ mesh: modelo.grupo, pernas: modelo.pernas, tipo: tipo, chunkId: `${cx},${cz}`, vy: 0, direcao: Math.random() * Math.PI * 2, tempoAcao: Math.random() * 3, andando: true, animTimer: 0 });
        }

        function gerarDadosChunk(cx, cz) {
            const id = obterIdChunk(cx, cz); if (chunksGerados.has(id)) return; chunksGerados.add(id);
            for (let lx = 0; lx < TAMANHO_CHUNK; lx++) {
                for (let lz = 0; lz < TAMANHO_CHUNK; lz++) {
                    const x = cx * TAMANHO_CHUNK + lx; const z = cz * TAMANHO_CHUNK + lz;
                    let alt = Math.floor(noise.noise(x / 30, 0, z / 30) * 8); 
                    for (let y = -15; y <= alt; y++) {
                        let buraco = noise.noise(x / 12, y / 12, z / 12);
                        if (y < alt - 2 && buraco > 0.4) continue;
                        let tipo = 3; if (y === alt) tipo = 1; else if (y > alt - 3) tipo = 2;
                        if (!mundo.has(`${x},${y},${z}`)) mundo.set(`${x},${y},${z}`, tipo);
                    }
                    if (Math.random() < 0.02 && mundo.get(`${x},${alt},${z}`) === 1) gerarArvore(x, alt + 1, z);
                }
            }
            if (Math.random() < 0.4) {
                const ax = cx * TAMANHO_CHUNK + Math.floor(Math.random() * TAMANHO_CHUNK);
                const az = cz * TAMANHO_CHUNK + Math.floor(Math.random() * TAMANHO_CHUNK);
                for (let y = 25; y >= -15; y--) { if (mundo.has(`${ax},${y},${az}`)) { criarAnimal(ax, y + 1.5, az, cx, cz); break; } }
            }
        }

        function construirChunkVisual(cx, cz) {
            const id = obterIdChunk(cx, cz); if (chunksVisuais.has(id)) return;
            const grupo = new THREE.Group(); const blocosChunk = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            for (let lx = 0; lx < TAMANHO_CHUNK; lx++) {
                for (let lz = 0; lz < TAMANHO_CHUNK; lz++) {
                    const x = cx * TAMANHO_CHUNK + lx; const z = cz * TAMANHO_CHUNK + lz;
                    for (let y = -15; y < 25; y++) {
                        const tipo = mundo.get(`${x},${y},${z}`);
                        if (tipo) {
                            const exposto = !mundo.has(`${x+1},${y},${z}`) || !mundo.has(`${x-1},${y},${z}`) || !mundo.has(`${x},${y+1},${z}`) || !mundo.has(`${x},${y-1},${z}`) || !mundo.has(`${x},${y},${z+1}`) || !mundo.has(`${x},${y},${z-1}`);
                            if (exposto) blocosChunk[tipo].push(new THREE.Vector3(x, y, z));
                        }
                    }
                }
            }
            for (let tipo in blocosChunk) {
                const pos = blocosChunk[tipo]; if (pos.length === 0) continue;
                const instancedMesh = new THREE.InstancedMesh(geometriaBloco, materiais[tipo], pos.length);
                const matriz = new THREE.Matrix4();
                pos.forEach((p, index) => { matriz.setPosition(p.x, p.y, p.z); instancedMesh.setMatrixAt(index, matriz); });
                instancedMesh.castShadow = true; instancedMesh.receiveShadow = true; grupo.add(instancedMesh);
            }
            cena.add(grupo); chunksVisuais.set(id, grupo);
        }

        function atualizarChunks() {
            const px = Math.floor(camera.position.x / TAMANHO_CHUNK); const pz = Math.floor(camera.position.z / TAMANHO_CHUNK);
            if (px !== chunkAtualX || pz !== chunkAtualZ || chunksVisuais.size === 0) {
                document.getElementById('loading').innerText = "Carregando √°rea..."; chunkAtualX = px; chunkAtualZ = pz;
                for (let cx = px - DISTANCIA_RENDER; cx <= px + DISTANCIA_RENDER; cx++) { for (let cz = pz - DISTANCIA_RENDER; cz <= pz + DISTANCIA_RENDER; cz++) { gerarDadosChunk(cx, cz); } }
                for (let cx = px - DISTANCIA_RENDER; cx <= px + DISTANCIA_RENDER; cx++) { for (let cz = pz - DISTANCIA_RENDER; cz <= pz + DISTANCIA_RENDER; cz++) { construirChunkVisual(cx, cz); } }
                for (const [id, grupo] of chunksVisuais.entries()) {
                    const [cx, cz] = id.split(',').map(Number);
                    if (Math.abs(cx - px) > DISTANCIA_RENDER || Math.abs(cz - pz) > DISTANCIA_RENDER) {
                        cena.remove(grupo); grupo.children.forEach(m => m.dispose()); chunksVisuais.delete(id);
                        animais = animais.filter(a => { if (a.chunkId === id) { cena.remove(a.mesh); return false; } return true; });
                    }
                }
                document.getElementById('loading').innerText = `Chunks ativos: ${chunksVisuais.size}`;
            }
        }

        function recriarChunkVisual(x, z) {
            const cx = Math.floor(x / TAMANHO_CHUNK); const cz = Math.floor(z / TAMANHO_CHUNK); const id = obterIdChunk(cx, cz);
            if (chunksVisuais.has(id)) { const grupo = chunksVisuais.get(id); cena.remove(grupo); grupo.children.forEach(m => m.dispose()); chunksVisuais.delete(id); construirChunkVisual(cx, cz); }
        }

        // üèÉ‚Äç‚ôÇÔ∏è CONTROLES
        camera.position.set(0, 20, 0);
        const teclas = { w: false, a: false, s: false, d: false, space: false };
        let velocidadeY = 0; let noChao = false;

        document.addEventListener('keydown', (e) => {
            if(e.code === 'KeyW') teclas.w = true; if(e.code === 'KeyS') teclas.s = true; if(e.code === 'KeyA') teclas.a = true; if(e.code === 'KeyD') teclas.d = true; if(e.code === 'Space') teclas.space = true;
            
            if(e.code === 'KeyE') {
                if (controles.isLocked) { controles.unlock(); craftingMenu.style.display = 'flex'; atualizarUI(); } 
                else { craftingMenu.style.display = 'none'; controles.lock(); }
            }

            if(['1','2','3','4','5','6','7'].includes(e.key)) {
                let numero = parseInt(e.key);
                if (numero === 6 && !inventario.picareta) return;
                if (numero === 7 && !inventario.machado) return;

                blocoSelecionado = numero;
                document.querySelectorAll('.slot').forEach(el => el.classList.remove('active'));
                document.getElementById(`slot-${blocoSelecionado}`).classList.add('active');
                atualizarMao(); 
            }
        });

        document.addEventListener('keyup', (e) => {
            if(e.code === 'KeyW') teclas.w = false; if(e.code === 'KeyS') teclas.s = false; if(e.code === 'KeyA') teclas.a = false; if(e.code === 'KeyD') teclas.d = false; if(e.code === 'Space') teclas.space = false;
        });

        function checarColisao(x, y, z) {
            const w = 0.2; 
            const pos = [[x-w, y-1.5, z-w], [x+w, y-1.5, z-w], [x-w, y-1.5, z+w], [x+w, y-1.5, z+w], [x-w, y-0.5, z-w], [x+w, y-0.5, z-w], [x-w, y-0.5, z+w], [x+w, y-0.5, z+w]];
            return pos.some(p => mundo.has(`${Math.floor(p[0])},${Math.floor(p[1])},${Math.floor(p[2])}`));
        }

        // üì¶ SISTEMA DE DROPS (ITENS NO CH√ÉO)
        let itensDropados = [];
        const geoDrop = new THREE.BoxGeometry(0.25, 0.25, 0.25);
        function droparItem(x, y, z, tipo) {
            const mesh = new THREE.Mesh(geoDrop, materiais[tipo]);
            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            mesh.castShadow = true; cena.add(mesh);
            itensDropados.push({ mesh, tipo, vy: 0.2 }); // D√° um pulinho ao nascer
        }

        // ‚õèÔ∏è INTERA√á√ÉO
        const raycaster = new THREE.Raycaster(); const centroTela = new THREE.Vector2(0, 0);
        document.addEventListener('mousedown', (e) => {
            if (!controles.isLocked) return;

            animandoMao = true; progressoMao = 0;
            raycaster.setFromCamera(centroTela, camera);
            const objetos = Array.from(chunksVisuais.values()).flatMap(g => g.children);
            const interseccoes = raycaster.intersectObjects(objetos);

            if (interseccoes.length > 0) {
                const hit = interseccoes[0]; const pt = hit.point; const normal = hit.face.normal;
                const nx = Math.round(normal.x); const ny = Math.round(normal.y); const nz = Math.round(normal.z);
                const hitX = Math.round(pt.x - nx * 0.5); const hitY = Math.round(pt.y - ny * 0.5); const hitZ = Math.round(pt.z - nz * 0.5);

                if (e.button === 0) { // Quebrar
                    const tipoBloco = mundo.get(`${hitX},${hitY},${hitZ}`);
                    
                    // ü™µ Spawna o drop do bloco!
                    if(tipoBloco) droparItem(hitX, hitY, hitZ, tipoBloco);

                    mundo.delete(`${hitX},${hitY},${hitZ}`);
                    recriarChunkVisual(hitX, hitZ);
                    if(hitX % TAMANHO_CHUNK === 0) recriarChunkVisual(hitX-1, hitZ); if(hitX % TAMANHO_CHUNK === TAMANHO_CHUNK-1) recriarChunkVisual(hitX+1, hitZ);
                    if(hitZ % TAMANHO_CHUNK === 0) recriarChunkVisual(hitX, hitZ-1); if(hitZ % TAMANHO_CHUNK === TAMANHO_CHUNK-1) recriarChunkVisual(hitX, hitZ+1);
                } else if (e.button === 2 && blocoSelecionado <= 5) { // Colocar
                    const placeX = hitX + nx; const placeY = hitY + ny; const placeZ = hitZ + nz;
                    const pX = camera.position.x; const pY = camera.position.y; const pZ = camera.position.z;
                    const dist = Math.sqrt((pX - (placeX+0.5))**2 + (pZ - (placeZ+0.5))**2);
                    const noJogador = dist < 0.6 && pY > placeY && pY - 2.0 < placeY;
                    
                    if (!noJogador) {
                        mundo.set(`${placeX},${placeY},${placeZ}`, blocoSelecionado);
                        recriarChunkVisual(placeX, placeZ);
                        if(placeX % TAMANHO_CHUNK === 0) recriarChunkVisual(placeX-1, placeZ); if(placeX % TAMANHO_CHUNK === TAMANHO_CHUNK-1) recriarChunkVisual(placeX+1, placeZ);
                        if(placeZ % TAMANHO_CHUNK === 0) recriarChunkVisual(placeX, placeZ-1); if(placeZ % TAMANHO_CHUNK === TAMANHO_CHUNK-1) recriarChunkVisual(placeX, placeZ+1);
                    }
                }
            }
        });

        const relogio = new THREE.Clock();
        function animar() {
            requestAnimationFrame(animar);
            if (controles.isLocked) {
                atualizarChunks(); const delta = relogio.getDelta();
                
                luzSol.position.set(camera.position.x + 20, camera.position.y + 40, camera.position.z + 20); luzSol.target.position.copy(camera.position);

                raycaster.setFromCamera(centroTela, camera);
                const objs = Array.from(chunksVisuais.values()).flatMap(g => g.children);
                const mira = raycaster.intersectObjects(objs);
                if (mira.length > 0) {
                    const n = mira[0].face.normal;
                    contornoBloco.position.set( Math.round(mira[0].point.x - Math.round(n.x) * 0.5), Math.round(mira[0].point.y - Math.round(n.y) * 0.5), Math.round(mira[0].point.z - Math.round(n.z) * 0.5) );
                    contornoBloco.visible = true;
                } else contornoBloco.visible = false;

                const velocidadeAndar = 5 * delta; const posAntiga = camera.position.clone();
                let moveZ = Number(teclas.w) - Number(teclas.s); let moveX = Number(teclas.a) - Number(teclas.d);
                let movendo = moveX !== 0 || moveZ !== 0;

                // ‚úã ANIMA√á√ÉO DA M√ÉO (Bobbing - Andando & Quebrando)
                if (animandoMao) {
                    progressoMao += delta * 15;
                    if (progressoMao > Math.PI) { animandoMao = false; grupoMao.rotation.x = 0; } 
                    else { grupoMao.rotation.x = -Math.sin(progressoMao) * 0.6; }
                }
                
                if (movendo && noChao) {
                    bobTimer += delta * 12; // Velocidade do balan√ßo
                    grupoMao.position.y = -0.4 + Math.abs(Math.sin(bobTimer)) * 0.05;
                    grupoMao.position.x = 0.6 + Math.sin(bobTimer/2) * 0.05;
                } else {
                    bobTimer = 0;
                    grupoMao.position.y = THREE.MathUtils.lerp(grupoMao.position.y, -0.4, 0.1);
                    grupoMao.position.x = THREE.MathUtils.lerp(grupoMao.position.x, 0.6, 0.1);
                }

                // üì¶ F√çSICA DOS DROPS & COLETA
                for (let i = itensDropados.length - 1; i >= 0; i--) {
                    let item = itensDropados[i];
                    item.vy -= 1.0 * delta; // Gravidade do item
                    item.mesh.position.y += item.vy;
                    item.mesh.rotation.y += delta; // Fica rodando bonitinho

                    const blockY = Math.floor(item.mesh.position.y - 0.125);
                    if (mundo.has(`${Math.floor(item.mesh.position.x)},${blockY},${Math.floor(item.mesh.position.z)}`)) {
                        item.mesh.position.y = blockY + 1 + 0.125; item.vy = 0; // Bateu no ch√£o
                    }

                    // Checa se o player t√° perto para coletar (Raio de 1.5 blocos)
                    const distToPlayer = camera.position.distanceTo(item.mesh.position);
                    if (distToPlayer < 1.5) {
                        if (item.tipo === 4) { inventario.madeira++; atualizarUI(); } // Coletou Madeira!
                        cena.remove(item.mesh); item.mesh.geometry.dispose();
                        itensDropados.splice(i, 1);
                    }
                }

                // üêÑ IA ANIMAIS
                animais.forEach(a => {
                    a.tempoAcao -= delta;
                    if (a.tempoAcao <= 0) { a.direcao = Math.random() * Math.PI * 2; a.andando = Math.random() > 0.3; a.tempoAcao = 1 + Math.random() * 3; }
                    if (a.andando) {
                        const vel = 1.0 * delta; a.mesh.position.x += Math.sin(a.direcao) * vel; a.mesh.position.z += Math.cos(a.direcao) * vel; a.mesh.rotation.y = a.direcao;
                        a.animTimer += delta * 10; a.pernas[0].rotation.x = Math.sin(a.animTimer) * 0.5; a.pernas[3].rotation.x = Math.sin(a.animTimer) * 0.5; a.pernas[1].rotation.x = -Math.sin(a.animTimer) * 0.5; a.pernas[2].rotation.x = -Math.sin(a.animTimer) * 0.5;
                        if (mundo.has(`${Math.floor(a.mesh.position.x)},${Math.floor(a.mesh.position.y)},${Math.floor(a.mesh.position.z)}`)) { a.direcao += Math.PI; a.mesh.position.x += Math.sin(a.direcao) * vel * 2; a.mesh.position.z += Math.cos(a.direcao) * vel * 2; }
                    } else { a.pernas.forEach(p => p.rotation.x = 0); }
                    a.vy -= 0.5 * delta; a.mesh.position.y += a.vy; const blocoBaixo = Math.floor(a.mesh.position.y - 0.4);
                    if (mundo.has(`${Math.floor(a.mesh.position.x)},${blocoBaixo},${Math.floor(a.mesh.position.z)}`)) { a.mesh.position.y = blocoBaixo + 1.4; a.vy = 0; if (a.andando && Math.random() < 0.05) a.vy = 0.15; }
                });

                const direcao = new THREE.Vector3(); camera.getWorldDirection(direcao); direcao.y = 0; direcao.normalize();
                const lado = new THREE.Vector3(); lado.crossVectors(camera.up, direcao).normalize();

                if (movendo) { 
                    const moveDir = new THREE.Vector2(moveX, moveZ).normalize(); 
                    const velX = (lado.x * moveDir.x + direcao.x * moveDir.y) * velocidadeAndar;
                    const velZ = (lado.z * moveDir.x + direcao.z * moveDir.y) * velocidadeAndar;
                    
                    camera.position.x += velX;
                    if (checarColisao(camera.position.x, posAntiga.y, posAntiga.z)) {
                        camera.position.x = posAntiga.x; 
                        if (noChao && !checarColisao(camera.position.x + velX, posAntiga.y + 1.1, posAntiga.z)) { velocidadeY = 0.2; camera.position.y += 0.1; noChao = false; }
                    }

                    camera.position.z += velZ;
                    if (checarColisao(camera.position.x, posAntiga.y, camera.position.z)) {
                        camera.position.z = posAntiga.z; 
                        if (noChao && !checarColisao(camera.position.x, posAntiga.y + 1.1, posAntiga.z + velZ)) { velocidadeY = 0.2; camera.position.y += 0.1; noChao = false; }
                    }
                }

                if (teclas.space && noChao) { velocidadeY = 0.15; noChao = false; }
                velocidadeY -= 0.5 * delta; camera.position.y += velocidadeY;

                if (checarColisao(camera.position.x, camera.position.y, camera.position.z)) { camera.position.y = posAntiga.y; velocidadeY = 0; noChao = true; } else noChao = false;
                if(camera.position.y < -30) { camera.position.set(camera.position.x, 20, camera.position.z); velocidadeY = 0; }
            } else relogio.getDelta();

            renderizador.render(cena, camera);
        }

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderizador.setSize(window.innerWidth, window.innerHeight); });
        atualizarChunks(); animar();
    </script>
</body>
</html>