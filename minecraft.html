<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meu Craft üåç - Vaca 3D, Drops & Anima√ß√£o</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #78A7FF;
            font-family: 'Press Start 2P', 'Courier New', Courier, monospace;
        }

        #vida-player {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 2px;
            z-index: 100;
        }

        .heart {
            width: 24px;
            height: 24px;
            background-size: cover;
            display: inline-block;
        }

        #damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 0, 0, 0);
            pointer-events: none;
            z-index: 99;
            transition: background 0.2s;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        #crosshair::before {
            top: 9px;
            left: 0;
            width: 20px;
            height: 2px;
        }

        #crosshair::after {
            top: 0;
            left: 9px;
            width: 2px;
            height: 20px;
        }

        #hotbar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            background: rgba(40, 40, 40, 0.85);
            /* HUD Background mais fechado */
            padding: 4px;
            border: 2px solid #111;
        }

        .slot {
            width: 48px;
            height: 48px;
            background-color: #8b8b8b;
            border-top: 3px solid #d4d4d4;
            border-left: 3px solid #d4d4d4;
            border-bottom: 3px solid #373737;
            border-right: 3px solid #373737;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background-size: 70%;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            image-rendering: pixelated;
        }

        .slot .qty {
            position: absolute;
            bottom: -2px;
            right: 2px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 0px #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            pointer-events: none;
        }

        .slot.active {
            box-shadow: 0 0 0 3px white inset, 0 0 0 5px rgba(255, 255, 255, 0.4);
            border: 3px solid #fff;
            z-index: 2;
        }

        #menu,
        #inventory-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 10;
        }

        #inventory-menu {
            display: none;
            background: rgba(60, 60, 60, 0.95);
            border: 4px solid #1e1e1e;
            width: 500px;
            height: 450px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            border-radius: 4px;
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin: 20px 0;
            image-rendering: pixelated;
            /* Pra interface retro */
        }

        .inv-item {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #555;
            padding: 10px;
            text-align: center;
            border-radius: 4px;
            position: relative;
        }

        .inv-item .qty {
            position: absolute;
            bottom: 4px;
            right: 6px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }

        .inv-item .icon {
            width: 32px;
            height: 32px;
            margin: 0 auto 5px;
            display: block;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .inv-item .name {
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
        }

        button {
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            border-bottom: 4px solid #388E3C;
            margin: 10px;
        }

        button:active {
            transform: translateY(4px);
            border-bottom: 0;
        }

        button:disabled {
            background: #888;
            border-bottom: 4px solid #555;
            cursor: not-allowed;
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            line-height: 1.5;
        }

        #loading {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }

        #recursos {
            position: absolute;
            top: 40px;
            left: 10px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            font-size: 18px;
        }

        /* üì± CONTROLES MOBILE (estilo Minecraft PE) */
        #mobile-controls {
            display: none;
            /* Mostrado via JS se touch */
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        #mobile-controls.active {
            display: block;
        }

        /* D-PAD (esquerda) */
        .dpad {
            position: absolute;
            bottom: 90px;
            left: 20px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }

        .dpad-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            text-shadow: 1px 1px 2px #000;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .dpad-btn:active,
        .dpad-btn.pressed {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.93);
        }

        .dpad-up {
            top: 0;
            left: 50px;
        }

        .dpad-down {
            bottom: 0;
            left: 50px;
        }

        .dpad-left {
            top: 50px;
            left: 0;
        }

        .dpad-right {
            top: 50px;
            right: 0;
        }

        /* BOT√ïES DE A√á√ÉO (direita) */
        .action-btns {
            position: absolute;
            bottom: 90px;
            right: 20px;
            width: 140px;
            height: 170px;
            pointer-events: auto;
        }

        .action-btn {
            position: absolute;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            color: white;
            text-shadow: 1px 1px 2px #000;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .action-btn:active,
        .action-btn.pressed {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.93);
        }

        .btn-jump {
            bottom: 0;
            right: 0;
            background: rgba(100, 200, 255, 0.3);
        }

        .btn-break {
            top: 0;
            left: 0;
            background: rgba(255, 100, 100, 0.3);
        }

        .btn-place {
            top: 0;
            right: 0;
            background: rgba(100, 255, 100, 0.3);
        }

        .btn-inv {
            bottom: 0;
            left: 0;
            background: rgba(200, 200, 100, 0.3);
        }

        /* Joystick de c√¢mera (√°rea direita superior - invis√≠vel) */
        .camera-zone {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 60%;
            pointer-events: auto;
            touch-action: none;
        }

        /* Sprint (toque duplo no W) */
        .btn-sprint {
            position: absolute;
            bottom: 250px;
            left: 55px;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: rgba(255, 165, 0, 0.3);
            border: 2px solid rgba(255, 165, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 2px #000;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        @media (min-width: 1025px) {
            #mobile-controls {
                display: none !important;
            }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "./systems/": "./js/systems/",
                "./world/": "./js/world/",
                "./ui/": "./js/ui/",
                "./scripts/mobs/": "./js/scripts/mobs/",
                "./items/": "./js/items/"
            }
        }
    </script>
</head>

<body>

    <div id="loading">üåç Carregando mundo...</div>
    <div id="recursos" style="display:none;"></div> <!-- Ocultando pq agora temos invent√°rio real -->
    <div id="vida-player"></div>
    <div id="damage-flash"></div>
    <div id="crosshair"></div>

    <div id="hotbar">
        <div class="slot active" id="slot-0"><span class="qty"></span></div>
        <div class="slot" id="slot-1"><span class="qty"></span></div>
        <div class="slot" id="slot-2"><span class="qty"></span></div>
        <div class="slot" id="slot-3"><span class="qty"></span></div>
        <div class="slot" id="slot-4"><span class="qty"></span></div>
        <div class="slot" id="slot-5"><span class="qty"></span></div>
        <div class="slot" id="slot-6"><span class="qty"></span></div>
    </div>

    <div id="menu">
        <h1>üåç Meu Craft Infinito</h1>
        <button id="btn-play">‚ñ∂Ô∏è Jogar</button>
        <div class="instructions">
            üèÉ‚Äç‚ôÇÔ∏è <b>WASD</b>: Andar | <b>Espa√ßo</b>: Pular | <b>Mouse</b>: Olhar<br>
            ‚õèÔ∏è <b>Clique Esq</b>: Quebrar | üß± <b>Clique Dir</b>: Colocar<br>
            üéí <b>1 a 7 / Scroll</b>: Hotbar | üéí <b>E</b>: Invent√°rio / Crafting<br>
        </div>
    </div>

    <div id="inventory-menu">
        <h2>üéí Invent√°rio & Crafting</h2>
        <div class="inv-grid" id="inv-grid">
            <!-- Items via JS -->
        </div>
        <hr style="width:100%; border:1px solid #444;">
        <div style="margin-top: 15px; display:flex; gap: 20px; align-items:center;">
            <div>
                <p>üõ†Ô∏è <b>Crafting:</b> Aproveite sua madeira!</p>
                <button id="btn-craft-picareta">Criar Picareta (5 Madeira)</button>
                <button id="btn-craft-machado">Criar Machado (5 Madeira)</button>
            </div>
            <button id="btn-fechar-inv" style="background:#555; box-shadow: 0 4px 0 #333;">Fechar (E)</button>
        </div>
    </div>

    <!-- üì± CONTROLES MOBILE -->
    <div id="mobile-controls">
        <div class="camera-zone" id="camera-zone"></div>
        <div class="dpad">
            <div class="dpad-btn dpad-up" data-key="w">‚ñ≤</div>
            <div class="dpad-btn dpad-down" data-key="s">‚ñº</div>
            <div class="dpad-btn dpad-left" data-key="a">‚óÄ</div>
            <div class="dpad-btn dpad-right" data-key="d">‚ñ∂</div>
        </div>
        <div class="btn-sprint" id="btn-sprint" data-key="ctrl">üèÉ</div>
        <div class="action-btns">
            <div class="action-btn btn-jump" id="btn-mobile-jump">‚¨Ü</div>
            <div class="action-btn btn-break" id="btn-mobile-break">‚õè</div>
            <div class="action-btn btn-place" id="btn-mobile-place">üß±</div>
            <div class="action-btn btn-inv" id="btn-mobile-inv">üéí</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
        import { SoundManager } from './systems/SoundManager.js';
        import { Ovelha } from './scripts/mobs/Ovelha.js';
        import { Vaca } from './scripts/mobs/Vaca.js';
        import { Porco } from './scripts/mobs/Porco.js';
        import { Cavaleiro } from './scripts/mobs/Cavaleiro.js';
        import { MonstroVazio } from './scripts/mobs/MonstroVazio.js';
        import { CavaleiroTrevas } from './scripts/mobs/CavaleiroTrevas.js';
        import { criarPicaretaElite } from './items/PicaretaElite.js';
        import { UIBuilder } from './ui/UIBuilder.js';
        import { WorldGenerator } from './world/WorldGenerator.js';

        // üü¢ CONFIGURA√á√ïES B√ÅSICAS
        const cena = new THREE.Scene();
        const corCeu = 0x78A7FF; // Azul mais parecido com o do Minecraft
        cena.background = new THREE.Color(corCeu);
        cena.fog = new THREE.Fog(corCeu, 20, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderizador = new THREE.WebGLRenderer({ antialias: false });
        renderizador.setSize(window.innerWidth, window.innerHeight);
        renderizador.shadowMap.enabled = true;
        renderizador.shadowMap.type = THREE.PCFSoftShadowMap;
        renderizador.autoClear = false; // Multi-pass para HUD
        document.body.appendChild(renderizador.domElement);

        const controles = new PointerLockControls(camera, document.body);
        const menu = document.getElementById('menu');
        const inventoryMenu = document.getElementById('inventory-menu');

        const soundManager = new SoundManager();
        let playerHP = 20;

        // üéí SISTEMA DE INVENT√ÅRIO
        const STACK_MAX = 64;

        // SVGs das Ferramentas UI
        let urlTransparente = "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=')";

        const svgPicareta = "url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 16 16%22><path d=%22M15 1 L9 1 L1 9 L3 11 L11 3 L15 3 Z%22 fill=%22%23BDBDBD%22 stroke=%22%23000%22/><path d=%22M10 6 L2 14 L4 16 L12 8 Z%22 fill=%22%23795548%22 stroke=%22%23000%22/></svg>')";
        const svgMachado = "url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 16 16%22><path d=%22M14 2 L8 2 L6 6 L12 8 Z%22 fill=%22%23BDBDBD%22 stroke=%22%23000%22/><path d=%22M10 6 L2 14 L4 16 L12 8 Z%22 fill=%22%23795548%22 stroke=%22%23000%22/></svg>')";

        const itemDefs = {
            1: { id: 1, nome: "Grama", svgBase: urlTransparente, type: "block" },
            2: { id: 2, nome: "Terra", svgBase: urlTransparente, type: "block" },
            3: { id: 3, nome: "Pedra", svgBase: urlTransparente, type: "block" },
            4: { id: 4, nome: "Mad.", svgBase: urlTransparente, type: "block" },
            5: { id: 5, nome: "Folha", svgBase: urlTransparente, type: "block" }
        };

        // Instancia√ß√£o movida para o topo.

        const uiBuilder = new UIBuilder();
        const world = new WorldGenerator(cena, uiBuilder, getAnimalFactory);

        let itemSegurado = null;

        function callRenderUI() {
            uiBuilder.renderUI(playerHP, atualizarMao);
        }

        // Callback para o construtor World instanciar entidades dentro de la√ßo C++
        function getAnimalFactory() {
            return (ax, y, az, cx, cz) => {
                const arr = [];
                const tipos = ['porco', 'vaca', 'ovelha'];
                const sumChunks = Math.abs(cx) + Math.abs(cz);

                const isDarkKnight = sumChunks > 0 && sumChunks % 15 === 0;
                const isKnight = sumChunks % 20 === 0 && Math.random() < 0.5;
                const isMob1 = sumChunks > 0 && sumChunks % 25 === 0;

                if (isDarkKnight) {
                    arr.push(new CavaleiroTrevas(cena, ax, y, az, `${cx},${cz}`));
                } else if (isMob1) {
                    arr.push(new MonstroVazio(cena, ax, y, az, `${cx},${cz}`));
                    arr.push(new MonstroVazio(cena, ax + 1.2, y, az + 1.2, `${cx},${cz}`));
                } else if (isKnight) {
                    arr.push(new Cavaleiro(cena, ax, y, az, `${cx},${cz}`));
                } else {
                    const tipo = tipos[Math.floor(Math.random() * tipos.length)];
                    if (tipo === 'ovelha') arr.push(new Ovelha(cena, ax, y, az, `${cx},${cz}`));
                    else if (tipo === 'vaca') arr.push(new Vaca(cena, ax, y, az, `${cx},${cz}`));
                    else arr.push(new Porco(cena, ax, y, az, `${cx},${cz}`));
                }
                return arr;
            };
        }
        window.addEventListener('playerDamage', (e) => {
            playerHP -= e.detail.amount;
            callRenderUI();
            const flash = document.getElementById('damage-flash');
            if (flash) {
                flash.style.background = 'rgba(255, 0, 0, 0.4)';
                setTimeout(() => flash.style.background = 'rgba(255, 0, 0, 0)', 200);
            }
            soundManager.playSound('hit');
            if (playerHP <= 0) {
                alert("Game Over! Voc√™ foi derrotado.");
                location.reload();
            }
        });

        document.getElementById('btn-play').addEventListener('click', () => {
            menu.style.display = 'none';
            controles.lock();
            if (soundManager.ctx.state === 'suspended') soundManager.ctx.resume();
        });

        document.getElementById('btn-fechar-inv').addEventListener('click', () => {
            inventoryMenu.style.display = 'none';
            controles.lock();
        });

        controles.addEventListener('unlock', () => {
            if (inventoryMenu.style.display !== 'flex') menu.style.display = 'flex';
        });

        document.getElementById('btn-craft-picareta').addEventListener('click', () => {
            if (uiBuilder.removeItem(4, 5)) { uiBuilder.hotbar[5].unlocked = true; callRenderUI(); }
        });
        document.getElementById('btn-craft-machado').addEventListener('click', () => {
            if (uiBuilder.removeItem(4, 5)) { uiBuilder.hotbar[6].unlocked = true; callRenderUI(); }
        });

        // üí° ILUMINA√á√ÉO
        cena.add(new THREE.AmbientLight(0xcce0ff, 0.4)); // Luz ambiente mais suave
        const luzSol = new THREE.DirectionalLight(0xfff5b6, 1.0); // Sol mais quente
        luzSol.position.set(20, 50, 20); luzSol.castShadow = true;
        luzSol.shadow.camera.left = -30; luzSol.shadow.camera.right = 30; luzSol.shadow.camera.top = 30; luzSol.shadow.camera.bottom = -30;
        luzSol.shadow.camera.near = 0.5; luzSol.shadow.camera.far = 100; luzSol.shadow.mapSize.width = 1024; luzSol.shadow.mapSize.height = 1024; luzSol.shadow.bias = -0.001;
        cena.add(luzSol); cena.add(luzSol.target);

        // üé® TEXTURAS DOS BLOCOS & UI
        function gerarTextura(tipo) {
            const canvas = document.createElement('canvas'); canvas.width = 16; canvas.height = 16; const ctx = canvas.getContext('2d');
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    let cor = ''; const ruido = Math.random() * 30 - 15;
                    if (tipo === 'grama_topo') cor = `rgb(${40 + ruido}, ${150 + ruido}, ${40 + ruido})`;
                    else if (tipo === 'grama_lado') cor = y < 4 ? `rgb(${40 + ruido}, ${150 + ruido}, ${40 + ruido})` : `rgb(${100 + ruido}, ${70 + ruido}, ${40 + ruido})`;
                    else if (tipo === 'terra') cor = `rgb(${100 + ruido}, ${70 + ruido}, ${40 + ruido})`;
                    else if (tipo === 'pedra') cor = `rgb(${120 + ruido}, ${120 + ruido}, ${120 + ruido})`;
                    else if (tipo === 'madeira') { const c = (x % 4 === 0 || x % 5 === 0) ? 60 : 90; cor = `rgb(${c + ruido}, ${c / 1.5 + ruido}, ${c / 3 + ruido})`; }
                    else if (tipo === 'folhas') { if (Math.random() > 0.3) cor = `rgb(${20 + ruido}, ${100 + ruido}, ${20 + ruido})`; else { ctx.clearRect(x, y, 1, 1); continue; } }
                    ctx.fillStyle = cor; ctx.fillRect(x, y, 1, 1);
                }
            }
            const dataUrl = canvas.toDataURL();

            const textura = new THREE.CanvasTexture(canvas);
            textura.magFilter = THREE.NearestFilter; textura.minFilter = THREE.NearestFilter; textura.colorSpace = THREE.SRGBColorSpace;
            return { obj: textura, dataUrl: dataUrl };
        }

        function gerarTexturaQuebra(progresso) {
            const canvas = document.createElement('canvas'); canvas.width = 100; canvas.height = 100; const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 100, 100);
            ctx.strokeStyle = 'rgba(20, 20, 20, 0.9)';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Rachaduras profundas padr√£o Hytale
            const crackPaths = [
                "M52 18 L48 32 L56 48 L44 65 M15 45 L32 42 L48 55",
                "M25 25 L38 42 L18 68 M78 20 L62 42 L88 58 M40 80 L55 72",
                "M5 12 L28 22 M92 92 L68 78 M12 88 L45 72 M75 45 L95 40",
                "M50 2 L50 98 M2 50 L98 50 M18 18 L82 82 M82 18 L18 82",
                "M35 35 m-15 0 a 15 15 0 1 0 30 0 a 15 15 0 1 0 -30 0 M65 65 m-10 0 a 10 10 0 1 0 20 0 a 10 10 0 1 0 -20 0"
            ];

            const maxStage = Math.min(5, Math.floor(progresso * 6));

            for (let i = 0; i < maxStage; i++) {
                ctx.stroke(new Path2D(crackPaths[i]));
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = tex.minFilter = THREE.NearestFilter; return tex;
        }

        const matQuebra = new THREE.MeshBasicMaterial({ transparent: true, polygonOffset: true, polygonOffsetFactor: -1 });
        const meshQuebra = new THREE.Mesh(new THREE.BoxGeometry(1.01, 1.01, 1.01), matQuebra);
        meshQuebra.visible = false; cena.add(meshQuebra);

        const texTerra = gerarTextura('terra');
        const texGramaTopo = gerarTextura('grama_topo');
        const texGramaLado = gerarTextura('grama_lado');
        const texPedra = gerarTextura('pedra');
        const texMadeira = gerarTextura('madeira');
        const texFolhas = gerarTextura('folhas');

        const matTerra = new THREE.MeshLambertMaterial({ map: texTerra.obj });
        const matGramaTopo = new THREE.MeshLambertMaterial({ map: texGramaTopo.obj });
        const matGramaLado = new THREE.MeshLambertMaterial({ map: texGramaLado.obj });

        const materiais = {
            1: [matGramaLado, matGramaLado, matGramaTopo, matTerra, matGramaLado, matGramaLado],
            2: matTerra,
            3: new THREE.MeshLambertMaterial({ map: texPedra.obj }),
            4: new THREE.MeshLambertMaterial({ map: texMadeira.obj }),
            5: new THREE.MeshLambertMaterial({ map: texFolhas.obj, transparent: true, alphaTest: 0.5 })
        };

        // Define texturas
        world.setMateriais(materiais);
        uiBuilder.setupTextures({
            GramaLado: `url(${texGramaLado.dataUrl})`,
            Terra: `url(${texTerra.dataUrl})`,
            Pedra: `url(${texPedra.dataUrl})`,
            Madeira: `url(${texMadeira.dataUrl})`,
            Folhas: `url(${texFolhas.dataUrl})`
        });
        callRenderUI();

        // ‚úã SISTEMA DA M√ÉO
        const cenaMao = new THREE.Scene();
        const cameraMao = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);

        const luzDirecionalMao = new THREE.DirectionalLight(0xffa873, 0.3); // Luz quente parecida com o Sol 
        luzDirecionalMao.position.set(1, 1, 1);
        cenaMao.add(luzDirecionalMao);
        cenaMao.add(new THREE.AmbientLight(0xcce0ff, 0.8)); // Luz ambiente

        const grupoMao = new THREE.Group();
        grupoMao.position.set(0.6, -0.4, -0.7);
        cameraMao.add(grupoMao); // Coloca em uma viewport fixa no centro
        cenaMao.add(cameraMao);
        cena.add(camera);

        const matMao = new THREE.MeshLambertMaterial({ color: 0xffccaa });
        const braco = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.6, 0.15), matMao);
        braco.position.set(0, -0.2, 0);
        braco.rotation.x = -Math.PI / 12; // Leve inclina√ß√£o para frente
        grupoMao.add(braco);

        function atualizarMao() {
            if (itemSegurado) grupoMao.remove(itemSegurado);
            const slot = uiBuilder.hotbar[uiBuilder.selectedHotbarIndex];

            if (slot.kind === "block") {
                if (uiBuilder.getItemCount(slot.itemId) > 0) {
                    itemSegurado = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), materiais[slot.itemId]);
                    itemSegurado.position.set(0, 0.1, -0.3);
                } else itemSegurado = null;
            } else if (slot.kind === "tool" && slot.unlocked) {
                if (slot.toolId === "picareta") {
                    itemSegurado = criarPicaretaElite();
                    // üîÑ TWEAK: Picareta na vertical estilo Minecraft, girada em 90 graus
                    // O bra√ßo invis√≠vel central do jogador segura a base
                    itemSegurado.rotation.x = -Math.PI / 4; // Bico ligeiramente pra frente
                    itemSegurado.rotation.y = Math.PI / 2;  // Rota√ß√£o de 90 graus no eixo Y (direita/esquerda)
                    itemSegurado.position.set(0, 0.1, -0.2);
                } else {
                    // Machado gen√©rico
                    itemSegurado = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.6, 0.3), new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                    itemSegurado.rotation.x = -Math.PI / 4;
                    itemSegurado.position.set(0, 0.3, -0.2);
                }
            } else itemSegurado = null;

            if (itemSegurado) {
                itemSegurado.traverse(c => {
                    if (c.isMesh) {
                        if (Array.isArray(c.material)) {
                            c.material = c.material.map(m => {
                                if (!m.isClonedForHand) {
                                    m = m.clone();
                                    m.depthTest = false;
                                    m.isClonedForHand = true;
                                }
                                return m;
                            });
                        } else {
                            if (!c.material.isClonedForHand) {
                                c.material = c.material.clone();
                                c.material.depthTest = false;
                                c.material.isClonedForHand = true;
                            }
                        }
                        c.renderOrder = 999;
                    }
                });
                grupoMao.add(itemSegurado);
            }
        }

        // Aplica o mesmo pro bra√ßo vazio (sempre por cima)
        braco.material = braco.material.clone();
        braco.material.depthTest = false;
        braco.renderOrder = 999;

        let animandoMao = false; let progressoMao = 0; let bobTimer = 0; // Para animar andando



        let animais = [];
        const geometriaBloco = new THREE.BoxGeometry(1, 1, 1);

        // üêÑ Listener para quando animais comem grama (bloco muda de tipo)
        window.addEventListener('blockChanged', (e) => {
            const { x, y, z } = e.detail;
            recriarChunkVisual(x, z);
            // Vizinhos
            if (x % TAMANHO_CHUNK === 0) recriarChunkVisual(x - 1, z);
            if (x % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(x + 1, z);
            if (z % TAMANHO_CHUNK === 0) recriarChunkVisual(x, z - 1);
            if (z % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(x, z + 1);
        });

        // üî≤ CONTORNO DO BLOCO MIRADO (Fino e sutil)
        const geoContorno = new THREE.EdgesGeometry(new THREE.BoxGeometry(1.002, 1.002, 1.002));
        const matContorno = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1, transparent: true, opacity: 0.4 });
        const contornoBloco = new THREE.LineSegments(geoContorno, matContorno);
        contornoBloco.visible = false; cena.add(contornoBloco);

        // üåç SISTEMA DE CHUNKS INFINITOS
        const mundo = new Map();
        const chunksGerados = new Set();
        const chunksVisuais = new Map();
        const TAMANHO_CHUNK = 16;
        const DISTANCIA_RENDER = 2;
        let chunkAtualX = -999, chunkAtualZ = -999;
        const noise = new ImprovedNoise();

        function obterIdChunk(cx, cz) { return `${cx},${cz}`; }

        function gerarArvore(x, y, z) {
            const altura = Math.floor(Math.random() * 3) + 4;
            for (let i = 0; i < altura; i++) { if (!mundo.has(`${x},${y + i},${z}`)) mundo.set(`${x},${y + i},${z}`, 4); }
            for (let fx = -2; fx <= 2; fx++) {
                for (let fz = -2; fz <= 2; fz++) {
                    for (let fy = altura - 2; fy <= altura + 1; fy++) {
                        const dist = Math.abs(fx) + Math.abs(fy - altura) + Math.abs(fz);
                        if (dist < 4 && !mundo.has(`${x + fx},${y + fy},${z + fz}`)) mundo.set(`${x + fx},${y + fy},${z + fz}`, 5);
                    }
                }
            }
        }

        function criarAnimal(x, y, z, cx, cz) {
            const tipos = ['porco', 'vaca', 'ovelha'];
            const sumChunks = Math.abs(cx) + Math.abs(cz);

            // Cavaleiro das Trevas a cada 15 chunks
            const isDarkKnight = sumChunks > 0 && sumChunks % 15 === 0;
            // Cavaleiro a cada 20 chunks
            const isKnight = sumChunks % 20 === 0 && Math.random() < 0.5;
            // Mob 1 (Monstro Vazio) a cada 25 chunks - Spawnamos 2
            const isMob1 = sumChunks > 0 && sumChunks % 25 === 0;

            if (isDarkKnight) {
                animais.push(new CavaleiroTrevas(cena, x, y, z, `${cx},${cz}`));
                return;
            }

            if (isMob1) {
                animais.push(new MonstroVazio(cena, x, y, z, `${cx},${cz}`));
                animais.push(new MonstroVazio(cena, x + 1.2, y, z + 1.2, `${cx},${cz}`));
                return;
            }

            let animal;
            if (isKnight) {
                animal = new Cavaleiro(cena, x, y, z, `${cx},${cz}`);
            } else {
                const tipo = tipos[Math.floor(Math.random() * tipos.length)];
                if (tipo === 'ovelha') animal = new Ovelha(cena, x, y, z, `${cx},${cz}`);
                else if (tipo === 'vaca') animal = new Vaca(cena, x, y, z, `${cx},${cz}`);
                else animal = new Porco(cena, x, y, z, `${cx},${cz}`);
            }

            animais.push(animal);
        }

        function gerarDadosChunk(cx, cz) {
            const id = obterIdChunk(cx, cz); if (chunksGerados.has(id)) return; chunksGerados.add(id);
            for (let lx = 0; lx < TAMANHO_CHUNK; lx++) {
                for (let lz = 0; lz < TAMANHO_CHUNK; lz++) {
                    const x = cx * TAMANHO_CHUNK + lx; const z = cz * TAMANHO_CHUNK + lz;
                    let alt = Math.floor(noise.noise(x / 30, 0, z / 30) * 8);
                    for (let y = -15; y <= alt; y++) {
                        let buraco = noise.noise(x / 12, y / 12, z / 12);
                        if (y < alt - 2 && buraco > 0.4) continue;
                        let tipo = 3; if (y === alt) tipo = 1; else if (y > alt - 3) tipo = 2;
                        if (!mundo.has(`${x},${y},${z}`)) mundo.set(`${x},${y},${z}`, tipo);
                    }
                    if (Math.random() < 0.02 && mundo.get(`${x},${alt},${z}`) === 1) gerarArvore(x, alt + 1, z);
                }
            }
            if (Math.random() < 0.4) {
                const ax = cx * TAMANHO_CHUNK + Math.floor(Math.random() * TAMANHO_CHUNK);
                const az = cz * TAMANHO_CHUNK + Math.floor(Math.random() * TAMANHO_CHUNK);
                for (let y = 25; y >= -15; y--) {
                    const tipo = mundo.get(`${ax},${y},${az}`);
                    if (tipo) {
                        if (tipo !== 5) { // N√£o nasce na Folha
                            criarAnimal(ax, y + 1.62, az, cx, cz);
                        }
                        break;
                    }
                }
            }
        }

        function construirChunkVisual(cx, cz) {
            const id = obterIdChunk(cx, cz); if (chunksVisuais.has(id)) return;
            const grupo = new THREE.Group(); const blocosChunk = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            for (let lx = 0; lx < TAMANHO_CHUNK; lx++) {
                for (let lz = 0; lz < TAMANHO_CHUNK; lz++) {
                    const x = cx * TAMANHO_CHUNK + lx; const z = cz * TAMANHO_CHUNK + lz;
                    for (let y = -15; y < 25; y++) {
                        const tipo = mundo.get(`${x},${y},${z}`);
                        if (tipo) {
                            const exposto = !mundo.has(`${x + 1},${y},${z}`) || !mundo.has(`${x - 1},${y},${z}`) || !mundo.has(`${x},${y + 1},${z}`) || !mundo.has(`${x},${y - 1},${z}`) || !mundo.has(`${x},${y},${z + 1}`) || !mundo.has(`${x},${y},${z - 1}`);
                            if (exposto) blocosChunk[tipo].push(new THREE.Vector3(x, y, z));
                        }
                    }
                }
            }
            for (let tipo in blocosChunk) {
                const pos = blocosChunk[tipo]; if (pos.length === 0) continue;
                const instancedMesh = new THREE.InstancedMesh(geometriaBloco, materiais[tipo], pos.length);
                const matriz = new THREE.Matrix4();
                pos.forEach((p, index) => { matriz.setPosition(p.x, p.y, p.z); instancedMesh.setMatrixAt(index, matriz); });
                instancedMesh.castShadow = true; instancedMesh.receiveShadow = true; grupo.add(instancedMesh);
            }
            cena.add(grupo); chunksVisuais.set(id, grupo);
        }

        function atualizarChunks() {
            const px = Math.floor(camera.position.x / TAMANHO_CHUNK); const pz = Math.floor(camera.position.z / TAMANHO_CHUNK);
            if (px !== chunkAtualX || pz !== chunkAtualZ || chunksVisuais.size === 0) {
                document.getElementById('loading').innerText = "Carregando √°rea..."; chunkAtualX = px; chunkAtualZ = pz;
                for (let cx = px - DISTANCIA_RENDER; cx <= px + DISTANCIA_RENDER; cx++) { for (let cz = pz - DISTANCIA_RENDER; cz <= pz + DISTANCIA_RENDER; cz++) { gerarDadosChunk(cx, cz); } }
                for (let cx = px - DISTANCIA_RENDER; cx <= px + DISTANCIA_RENDER; cx++) { for (let cz = pz - DISTANCIA_RENDER; cz <= pz + DISTANCIA_RENDER; cz++) { construirChunkVisual(cx, cz); } }
                for (const [id, grupo] of chunksVisuais.entries()) {
                    const [cx, cz] = id.split(',').map(Number);
                    if (Math.abs(cx - px) > DISTANCIA_RENDER || Math.abs(cz - pz) > DISTANCIA_RENDER) {
                        cena.remove(grupo); grupo.children.forEach(m => m.dispose()); chunksVisuais.delete(id);
                        animais = animais.filter(a => { if (a.chunkId === id) { cena.remove(a.mesh); return false; } return true; });
                    }
                }
                document.getElementById('loading').innerText = `Chunks ativos: ${chunksVisuais.size}`;

                if (!window.playerSpawned && chunksVisuais.size > 0) {
                    for (let y = 25; y >= -15; y--) {
                        if (mundo.has(`0,${y},0`)) {
                            camera.position.set(0, y + 2.12, 0); // y+0.5 da superficie + 1.62 do player
                            window.playerSpawned = true;
                            velocidadeY = 0;
                            break;
                        }
                    }
                }
            }
        }

        function recriarChunkVisual(x, z) {
            const cx = Math.floor(x / TAMANHO_CHUNK); const cz = Math.floor(z / TAMANHO_CHUNK); const id = obterIdChunk(cx, cz);
            if (chunksVisuais.has(id)) { const grupo = chunksVisuais.get(id); cena.remove(grupo); grupo.children.forEach(m => m.dispose()); chunksVisuais.delete(id); construirChunkVisual(cx, cz); }
        }

        // üèÉ‚Äç‚ôÇÔ∏è CONTROLES
        camera.position.set(0, 60, 0); // Come√ßa alto e depois teleporta no spawn
        const teclas = { w: false, a: false, s: false, d: false, space: false, ctrl: false };
        let velocidadeY = 0; let noChao = false;
        let sprintAtivo = false;
        let ultimoW = 0; // Para detectar double-tap do W

        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyW') {
                if (!teclas.w) { // S√≥ conta double-tap se W n√£o estava pressionado
                    const agora = performance.now();
                    if (agora - ultimoW < 300) { // 300ms = janela de double-tap
                        sprintAtivo = true;
                        teclas.ctrl = true;
                    }
                    ultimoW = agora;
                }
                teclas.w = true;
            }
            if (e.code === 'KeyS') teclas.s = true; if (e.code === 'KeyA') teclas.a = true; if (e.code === 'KeyD') teclas.d = true; if (e.code === 'Space') teclas.space = true; if (e.code === 'ControlLeft' || e.code === 'ControlRight') teclas.ctrl = true;

            if (e.key >= '1' && e.key <= '7') {
                uiBuilder.selectedHotbarIndex = parseInt(e.key) - 1;
                callRenderUI();
            }
            if (e.key.toLowerCase() === 'e') {
                if (inventoryMenu.style.display === 'flex') {
                    inventoryMenu.style.display = 'none';
                    controles.lock();
                } else {
                    inventoryMenu.style.display = 'flex';
                    menu.style.display = 'none';
                    controles.unlock();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW') { teclas.w = false; if (sprintAtivo) { sprintAtivo = false; teclas.ctrl = false; } }
            if (e.code === 'KeyS') teclas.s = false; if (e.code === 'KeyA') teclas.a = false; if (e.code === 'KeyD') teclas.d = false; if (e.code === 'Space') teclas.space = false; if (e.code === 'ControlLeft' || e.code === 'ControlRight') teclas.ctrl = false;
        });

        document.addEventListener('wheel', (e) => {
            if (!(controles.isLocked || window._mobileMode)) return;
            if (e.deltaY > 0) uiBuilder.selectedHotbarIndex = (uiBuilder.selectedHotbarIndex + 1) % 7;
            else uiBuilder.selectedHotbarIndex = (uiBuilder.selectedHotbarIndex - 1 + 7) % 7;
            callRenderUI();
        });

        function checarColisao(x, y, z) {
            const w = 0.15; // Menor para passar em buracos de 1 bloco com facilidade
            const pos = [
                [x - w, y - 1.62, z - w], [x + w, y - 1.62, z - w], [x - w, y - 1.62, z + w], [x + w, y - 1.62, z + w], // P√©s
                [x - w, y - 0.8, z - w], [x + w, y - 0.8, z - w], [x - w, y - 0.8, z + w], [x + w, y - 0.8, z + w],    // Cintura
                [x - w, y + 0.1, z - w], [x + w, y + 0.1, z - w], [x - w, y + 0.1, z + w], [x + w, y + 0.1, z + w]      // Cabe√ßa
            ];
            return pos.some(p => mundo.has(`${Math.round(p[0])},${Math.round(p[1])},${Math.round(p[2])}`));
        }

        // üì¶ SISTEMA DE DROPS (ITENS NO CH√ÉO)
        let itensDropados = [];
        const geoDrop = new THREE.BoxGeometry(0.25, 0.25, 0.25);
        function droparItem(x, y, z, tipo) {
            const mesh = new THREE.Mesh(geoDrop, materiais[tipo]);
            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            mesh.castShadow = true; cena.add(mesh);
            itensDropados.push({ mesh, tipo, vy: 0.2 }); // D√° um pulinho ao nascer
        }

        // üå´Ô∏è PART√çCULAS (DEBRIS)
        let particulasQuebra = [];
        const geoParticula = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        function criarParticulas(x, y, z, tipoBloco, qtde = 15) {
            let matBase = materiais[tipoBloco];
            const mat = Array.isArray(matBase) ? matBase[2] : (matBase || materiais[2]);

            for (let i = 0; i < qtde; i++) {
                const p = new THREE.Mesh(geoParticula, mat);
                p.position.set(x + Math.random(), y + Math.random(), z + Math.random());
                const angle = Math.random() * Math.PI * 2;
                const speed = 1.0 + Math.random() * 2;
                p.userData = {
                    vx: Math.cos(angle) * speed,
                    vy: 2 + Math.random() * 3,
                    vz: Math.sin(angle) * speed,
                    life: 0.6 + Math.random() * 0.6
                };
                cena.add(p);
                particulasQuebra.push(p);
            }
        }

        // ‚õèÔ∏è INTERA√á√ÉO & COMBATE
        const raycaster = new THREE.Raycaster(); const centroTela = new THREE.Vector2(0, 0);
        let quebrandoBloco = null;
        let tempoQuebrando = 0;
        let tempoAtualParaQuebrar = 1.3;
        const TEMPO_PARA_QUEBRAR = 1.3;

        function balancarMao() {
            animandoMao = true;
            progressoMao = 0;
        }

        document.addEventListener('mousedown', (e) => {
            if (!(controles.isLocked || window._mobileMode)) return;

            balancarMao(); // Toda vez que clica, balan√ßa a m√£o

            if (e.button === 0) { // Tentativa de quebrar
                raycaster.setFromCamera(centroTela, camera);
                const objetos = Array.from(chunksVisuais.values()).flatMap(g => g.children);
                const interseccoes = raycaster.intersectObjects(objetos);

                if (interseccoes.length > 0) {
                    const hit = interseccoes[0];
                    const pt = hit.point; const normal = hit.face.normal;
                    const hitX = Math.round(pt.x - normal.x * 0.5);
                    const hitY = Math.round(pt.y - normal.y * 0.5);
                    const hitZ = Math.round(pt.z - normal.z * 0.5);
                    quebrandoBloco = { x: hitX, y: hitY, z: hitZ };
                    tempoQuebrando = 0;
                } else {
                    // Tenta bater em animal
                    const animalIntersects = raycaster.intersectObjects(animais.map(a => a.mesh), true);
                    if (animalIntersects.length > 0) {
                        const meshHit = animalIntersects[0].object;
                        const animal = animais.find(a => {
                            let isChild = false;
                            a.mesh.traverse(child => { if (child === meshHit) isChild = true; });
                            return isChild;
                        });
                        if (animal) animal.sofrerDano(5, soundManager);
                        animandoMao = true; progressoMao = 0;
                    }
                }
            } else if (e.button === 2) { // Colocar
                const slot = uiBuilder.hotbar[uiBuilder.selectedHotbarIndex];
                if (slot.kind !== "block" || uiBuilder.getItemCount(slot.itemId) === 0) return;

                raycaster.setFromCamera(centroTela, camera);
                const objetos = Array.from(chunksVisuais.values()).flatMap(g => g.children);
                const interseccoes = raycaster.intersectObjects(objetos);
                if (interseccoes.length > 0) {
                    const hit = interseccoes[0]; const pt = hit.point; const normal = hit.face.normal;
                    const nx = Math.round(normal.x); const ny = Math.round(normal.y); const nz = Math.round(normal.z);
                    const hitX = Math.round(pt.x - nx * 0.5); const hitY = Math.round(pt.y - ny * 0.5); const hitZ = Math.round(pt.z - nz * 0.5);
                    const placeX = hitX + nx; const placeY = hitY + ny; const placeZ = hitZ + nz;

                    // Bloqueia se o bloco colidir com a hitbox do jogador (p√©s, corpo, cabe√ßa)
                    const px = camera.position.x, py = camera.position.y, pz = camera.position.z;
                    const playerMinX = px - 0.3, playerMaxX = px + 0.3;
                    const playerMinZ = pz - 0.3, playerMaxZ = pz + 0.3;
                    const playerMinY = py - 1.62, playerMaxY = py + 0.18;
                    const blockMinX = placeX - 0.5, blockMaxX = placeX + 0.5;
                    const blockMinY = placeY - 0.5, blockMaxY = placeY + 0.5;
                    const blockMinZ = placeZ - 0.5, blockMaxZ = placeZ + 0.5;
                    const overlaps = playerMinX < blockMaxX && playerMaxX > blockMinX &&
                        playerMinY < blockMaxY && playerMaxY > blockMinY &&
                        playerMinZ < blockMaxZ && playerMaxZ > blockMinZ;
                    if (overlaps) return;

                    if (!mundo.has(`${placeX},${placeY},${placeZ}`)) {
                        mundo.set(`${placeX},${placeY},${placeZ}`, slot.itemId);
                        soundManager.playSound('place');
                        uiBuilder.removeItem(slot.itemId, 1);
                        callRenderUI();
                        recriarChunkVisual(placeX, placeZ);
                        // Vizinhos
                        if (placeX % TAMANHO_CHUNK === 0) recriarChunkVisual(placeX - 1, placeZ);
                        if (placeX % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(placeX + 1, placeZ);
                        if (placeZ % TAMANHO_CHUNK === 0) recriarChunkVisual(placeX, placeZ - 1);
                        if (placeZ % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(placeX, placeZ + 1);
                    }
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                quebrandoBloco = null;
                tempoQuebrando = 0;
                contornoBloco.scale.set(1, 1, 1);
            }
        });

        const relogio = new THREE.Clock();
        function animar() {
            requestAnimationFrame(animar);
            if ((controles.isLocked || window._mobileMode)) {
                atualizarChunks(); const delta = relogio.getDelta();

                luzSol.position.set(camera.position.x + 20, camera.position.y + 40, camera.position.z + 20); luzSol.target.position.copy(camera.position);

                raycaster.setFromCamera(centroTela, camera);
                const objs = Array.from(chunksVisuais.values()).flatMap(g => g.children);
                const mira = raycaster.intersectObjects(objs);
                if (mira.length > 0) {
                    const n = mira[0].face.normal;
                    contornoBloco.position.set(Math.round(mira[0].point.x - Math.round(n.x) * 0.5), Math.round(mira[0].point.y - Math.round(n.y) * 0.5), Math.round(mira[0].point.z - Math.round(n.z) * 0.5));
                    contornoBloco.visible = true;
                } else contornoBloco.visible = false;

                let velocidadeAndar = (teclas.ctrl ? 10 : 5); // x2 speed for sprint
                if (!noChao) velocidadeAndar = 5; // Acelera√ß√£o menor no ar, mas manteve limita√ß√£o basi.
                velocidadeAndar *= delta;

                const posAntiga = camera.position.clone();
                let moveZ = Number(teclas.w) - Number(teclas.s); let moveX = Number(teclas.a) - Number(teclas.d);
                let movendo = moveX !== 0 || moveZ !== 0;

                // ‚úã ANIMA√á√ÉO DA M√ÉO (Bobbing & Clicar)
                if (animandoMao) {
                    // Swing da batida de machado/picareta ("Hit animation")
                    progressoMao += delta * 20;
                    if (progressoMao > Math.PI) {
                        animandoMao = false;
                        grupoMao.rotation.x = 0;
                    } else {
                        // Swing natural (baixa e volta)
                        grupoMao.rotation.x = -Math.sin(progressoMao) * 0.8;
                    }
                }

                if (movendo && noChao) {
                    bobTimer += delta * 15; // Velocidade do balan√ßo mais r√°pido
                    grupoMao.position.y = -0.4 + Math.abs(Math.sin(bobTimer)) * 0.05;
                    grupoMao.position.x = 0.6 + Math.sin(bobTimer / 2) * 0.05;
                } else {
                    bobTimer = 0;
                    grupoMao.position.y = THREE.MathUtils.lerp(grupoMao.position.y, -0.4, 0.2);
                    grupoMao.position.x = THREE.MathUtils.lerp(grupoMao.position.x, 0.6, 0.2);
                }

                // üì¶ F√çSICA DOS DROPS & COLETA
                for (let i = itensDropados.length - 1; i >= 0; i--) {
                    let item = itensDropados[i];
                    item.vy -= 1.0 * delta;
                    item.mesh.position.y += item.vy;
                    item.mesh.rotation.y += delta;

                    const xDir = Math.round(item.mesh.position.x);
                    const zDir = Math.round(item.mesh.position.z);
                    const bot = item.mesh.position.y - 0.125;
                    const blockY = Math.round(bot - 0.1);
                    if (item.vy <= 0 && mundo.has(`${xDir},${blockY},${zDir}`)) {
                        if (bot <= blockY + 0.5) {
                            item.mesh.position.y = blockY + 0.625;
                            item.vy = 0;
                        }
                    }

                    // Coleta universal com √≠m√£ de 2 blocos
                    const distToPlayer = camera.position.distanceTo(item.mesh.position);
                    if (distToPlayer < 2.0) {
                        if (uiBuilder.addItem(item.tipo, 1)) {
                            soundManager.playSound('collect');
                            callRenderUI();
                            cena.remove(item.mesh); item.mesh.geometry.dispose();
                            itensDropados.splice(i, 1);
                        }
                    }
                }

                // üå´Ô∏è ATUALIZA PART√çCULAS
                for (let i = particulasQuebra.length - 1; i >= 0; i--) {
                    let p = particulasQuebra[i];
                    p.position.x += p.userData.vx * delta;
                    p.position.y += p.userData.vy * delta;
                    p.position.z += p.userData.vz * delta;
                    p.userData.vy -= 15 * delta; // Gravidade part√≠culas
                    p.rotation.x += delta * 15;
                    p.rotation.y += delta * 15;
                    p.userData.life -= delta * 2;
                    p.scale.setScalar(Math.max(0, p.userData.life));
                    if (p.userData.life <= 0) {
                        cena.remove(p);
                        particulasQuebra.splice(i, 1);
                    }
                }

                // ‚õèÔ∏è L√ìGICA DE QUEBRA GRADUAL
                if (quebrandoBloco) {
                    // Verifica se o bloco que estamos quebrando ainda existe
                    const chaveBloco = `${quebrandoBloco.x},${quebrandoBloco.y},${quebrandoBloco.z}`;
                    const tipoBlocoQuebrando = mundo.get(chaveBloco);
                    if (!tipoBlocoQuebrando) {
                        // Bloco j√° foi removido, cancela
                        quebrandoBloco = null; tempoQuebrando = 0;
                        contornoBloco.scale.set(1, 1, 1); meshQuebra.visible = false;
                    }
                }
                if (quebrandoBloco) {
                    tempoQuebrando += delta;
                    animandoMao = true;
                    progressoMao += delta * 5;

                    const tipoBlocoQuebrando = mundo.get(`${quebrandoBloco.x},${quebrandoBloco.y},${quebrandoBloco.z}`);
                    tempoAtualParaQuebrar = TEMPO_PARA_QUEBRAR;
                    const slotAtivo = uiBuilder.hotbar[uiBuilder.selectedHotbarIndex];
                    if (tipoBlocoQuebrando === 3 && slotAtivo.kind === "tool" && slotAtivo.toolId === "picareta" && slotAtivo.unlocked) {
                        tempoAtualParaQuebrar = 0.3;
                    }
                    if (tipoBlocoQuebrando === 4 && slotAtivo.kind === "tool" && slotAtivo.toolId === "machado" && slotAtivo.unlocked) {
                        tempoAtualParaQuebrar = 0.3;
                    }

                    const prog = tempoQuebrando / tempoAtualParaQuebrar;

                    // Mostra as rachaduras com efeito de Shake e Redu√ß√£o visual (ilus√£o √≥ptica nas texturas adjacentes)
                    meshQuebra.visible = true;
                    const shakeInt = prog * 0.05;
                    meshQuebra.position.set(
                        quebrandoBloco.x + (Math.random() - 0.5) * shakeInt,
                        quebrandoBloco.y + (Math.random() - 0.5) * shakeInt,
                        quebrandoBloco.z + (Math.random() - 0.5) * shakeInt
                    );

                    if (Math.floor(tempoQuebrando * 10) % 2 === 0) {
                        matQuebra.map = gerarTexturaQuebra(prog);
                        matQuebra.needsUpdate = true;
                    }

                    // Tweak org√¢nico na "hitbox" selecionada
                    const scale = 1.0 + Math.sin(tempoQuebrando * 20) * 0.03;
                    contornoBloco.scale.set(scale, scale, scale);

                    // Solta pequenas part√≠culas durante a escava√ß√£o
                    if (Math.random() < 0.2 && tipoBlocoQuebrando) {
                        criarParticulas(quebrandoBloco.x, quebrandoBloco.y, quebrandoBloco.z, tipoBlocoQuebrando, 1);
                    }

                    if (tempoQuebrando >= tempoAtualParaQuebrar) {
                        const { x, y, z } = quebrandoBloco;

                        // RESET IMEDIATO para n√£o acumular frames
                        tempoQuebrando = 0;
                        quebrandoBloco = null;
                        contornoBloco.scale.set(1, 1, 1);
                        meshQuebra.visible = false;

                        if (tipoBlocoQuebrando) {
                            criarParticulas(x, y, z, tipoBlocoQuebrando, 20);

                            // Drop √∫nico garantido: deleta do mundo ANTES
                            mundo.delete(`${x},${y},${z}`);
                            droparItem(x, y, z, tipoBlocoQuebrando);
                            soundManager.playSound('pop');

                            recriarChunkVisual(x, z);
                            if (x % TAMANHO_CHUNK === 0) recriarChunkVisual(x - 1, z);
                            if (x % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(x + 1, z);
                            if (z % TAMANHO_CHUNK === 0) recriarChunkVisual(x, z - 1);
                            if (z % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(x, z + 1);
                        }
                    }
                } else {
                    tempoQuebrando = 0;
                    meshQuebra.visible = false;
                }

                // üêÑ IA ANIMAIS
                animais.forEach(a => a.update(delta, mundo, camera));

                const direcao = new THREE.Vector3(); camera.getWorldDirection(direcao); direcao.y = 0; direcao.normalize();
                const lado = new THREE.Vector3(); lado.crossVectors(camera.up, direcao).normalize();

                if (movendo) {
                    const moveDir = new THREE.Vector2(moveX, moveZ).normalize();
                    const velX = (lado.x * moveDir.x + direcao.x * moveDir.y) * velocidadeAndar;
                    const velZ = (lado.z * moveDir.x + direcao.z * moveDir.y) * velocidadeAndar;

                    camera.position.x += velX;
                    if (checarColisao(camera.position.x, posAntiga.y, posAntiga.z)) {
                        camera.position.x = posAntiga.x;
                        if (noChao && !checarColisao(camera.position.x + velX, posAntiga.y + 1.1, posAntiga.z)) { velocidadeY = 0.2; camera.position.y += 0.1; noChao = false; }
                    }

                    camera.position.z += velZ;
                    if (checarColisao(camera.position.x, posAntiga.y, camera.position.z)) {
                        camera.position.z = posAntiga.z;
                        if (noChao && !checarColisao(camera.position.x, posAntiga.y + 1.1, posAntiga.z + velZ)) { velocidadeY = 0.2; camera.position.y += 0.1; noChao = false; }
                    }
                }

                if (teclas.space && noChao) { velocidadeY = 0.22; noChao = false; soundManager.playSound('jump'); } // Pulo mais forte (Minecraft)
                velocidadeY -= 0.6 * delta; camera.position.y += velocidadeY; // Gravidade mais forte

                if (checarColisao(camera.position.x, camera.position.y, camera.position.z)) { camera.position.y = posAntiga.y; velocidadeY = 0; noChao = true; } else noChao = false;
                if (camera.position.y < -30) { camera.position.set(camera.position.x, 20, camera.position.z); velocidadeY = 0; }
            } else relogio.getDelta();

            renderizador.clear();
            renderizador.render(cena, camera);
            renderizador.clearDepth();
            renderizador.render(cenaMao, cameraMao);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            cameraMao.aspect = window.innerWidth / window.innerHeight;
            cameraMao.updateProjectionMatrix();
            renderizador.setSize(window.innerWidth, window.innerHeight);
        });
        atualizarChunks(); animar();

        // üì± CONTROLES MOBILE
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (isMobile) {
            const mc = document.getElementById('mobile-controls');
            mc.classList.add('active');

            // D-PAD: pressionar/soltar mapeia para teclas virtuais
            document.querySelectorAll('.dpad-btn').forEach(btn => {
                const key = btn.dataset.key;
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); teclas[key] = true; btn.classList.add('pressed'); }, { passive: false });
                btn.addEventListener('touchend', (e) => { e.preventDefault(); teclas[key] = false; btn.classList.remove('pressed'); }, { passive: false });
                btn.addEventListener('touchcancel', (e) => { teclas[key] = false; btn.classList.remove('pressed'); });
            });

            // SPRINT
            const sprintBtn = document.getElementById('btn-sprint');
            let sprintAtivo = false;
            sprintBtn.addEventListener('touchstart', (e) => { e.preventDefault(); sprintAtivo = !sprintAtivo; teclas.ctrl = sprintAtivo; sprintBtn.classList.toggle('pressed', sprintAtivo); }, { passive: false });

            // PULAR
            document.getElementById('btn-mobile-jump').addEventListener('touchstart', (e) => { e.preventDefault(); teclas.space = true; }, { passive: false });
            document.getElementById('btn-mobile-jump').addEventListener('touchend', (e) => { e.preventDefault(); teclas.space = false; }, { passive: false });

            // QUEBRAR (simula mousedown esquerdo)
            const btnBreak = document.getElementById('btn-mobile-break');
            btnBreak.addEventListener('touchstart', (e) => {
                e.preventDefault(); btnBreak.classList.add('pressed');
                document.dispatchEvent(new MouseEvent('mousedown', { button: 0 }));
            }, { passive: false });
            btnBreak.addEventListener('touchend', (e) => {
                e.preventDefault(); btnBreak.classList.remove('pressed');
                document.dispatchEvent(new MouseEvent('mouseup', { button: 0 }));
            }, { passive: false });

            // COLOCAR (simula mousedown direito) 
            const btnPlace = document.getElementById('btn-mobile-place');
            btnPlace.addEventListener('touchstart', (e) => {
                e.preventDefault(); btnPlace.classList.add('pressed');
                document.dispatchEvent(new MouseEvent('mousedown', { button: 2 }));
            }, { passive: false });
            btnPlace.addEventListener('touchend', (e) => { e.preventDefault(); btnPlace.classList.remove('pressed'); }, { passive: false });

            // INVENT√ÅRIO
            document.getElementById('btn-mobile-inv').addEventListener('touchstart', (e) => {
                e.preventDefault();
                const inv = document.getElementById('inventory-menu');
                if (inv.style.display === 'flex') {
                    inv.style.display = 'none';
                } else {
                    inv.style.display = 'flex';
                    document.getElementById('menu').style.display = 'none';
                }
            }, { passive: false });

            // C√ÇMERA (arrastar para olhar ao redor)
            const cameraZone = document.getElementById('camera-zone');
            let lastTouchX = 0, lastTouchY = 0;
            let cameraTouch = null;

            cameraZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const t = e.changedTouches[0];
                cameraTouch = t.identifier;
                lastTouchX = t.clientX;
                lastTouchY = t.clientY;
            }, { passive: false });

            cameraZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === cameraTouch) {
                        const dx = t.clientX - lastTouchX;
                        const dy = t.clientY - lastTouchY;
                        // Rotaciona c√¢mera
                        camera.rotation.order = 'YXZ';
                        camera.rotation.y -= dx * 0.004;
                        camera.rotation.x -= dy * 0.004;
                        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                        lastTouchX = t.clientX;
                        lastTouchY = t.clientY;
                    }
                }
            }, { passive: false });

            cameraZone.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === cameraTouch) cameraTouch = null;
                }
            });

            // No mobile, inicia sem PointerLock ‚Äî usa touch para olhar
            document.getElementById('btn-play').addEventListener('click', () => {
                menu.style.display = 'none';
                // Simula que os controles est√£o ativos sem PointerLock
                window._mobileMode = true;
            });
        }
    </script>
</body>

</html>