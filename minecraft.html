<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meu Craft üåç - Vaca 3D, Drops & Anima√ß√£o</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Courier New', Courier, monospace;
        }

        #vida-player {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ff4444;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            font-size: 24px;
            z-index: 100;
        }

        #damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 0, 0, 0);
            pointer-events: none;
            z-index: 99;
            transition: background 0.2s;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        #crosshair::before {
            top: 9px;
            left: 0;
            width: 20px;
            height: 2px;
        }

        #crosshair::after {
            top: 0;
            left: 9px;
            width: 2px;
            height: 20px;
        }

        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 5px;
        }

        .slot {
            width: 50px;
            height: 50px;
            border: 3px solid #555;
            display: flex;
            align-items: flex-end;
            justify-content: flex-end;
            color: white;
            font-weight: bold;
            font-size: 14px;
            padding: 2px;
            box-sizing: border-box;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
            background-size: cover;
            background-position: center;
            image-rendering: pixelated;
            /* üßä Texturas ficam pixeladas na UI */
        }

        .slot.active {
            border-color: #FFF;
            transform: scale(1.1);
        }

        /* Ferramentas (Desbloque√°veis) */
        #slot-6,
        #slot-7 {
            background-color: #444;
            display: none;
        }

        #menu,
        #crafting-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 10;
        }

        #crafting-menu {
            display: none;
            background: rgba(139, 69, 19, 0.9);
            border: 10px solid #5C4033;
            width: 400px;
            height: 300px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        button {
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            border-bottom: 4px solid #388E3C;
            margin: 10px;
        }

        button:active {
            transform: translateY(4px);
            border-bottom: 0;
        }

        button:disabled {
            background: #888;
            border-bottom: 4px solid #555;
            cursor: not-allowed;
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            line-height: 1.5;
        }

        #loading {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }

        #recursos {
            position: absolute;
            top: 40px;
            left: 10px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            font-size: 18px;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "./systems/": "./js/systems/",
                "./mobs/": "./js/mobs/"
            }
        }
    </script>
</head>

<body>

    <div id="loading">üåç Carregando mundo...</div>
    <div id="recursos">ü™µ Madeira: <span id="qtd-madeira">0</span></div>
    <div id="vida-player">‚ù§Ô∏è Life: <span id="player-hp">20</span></div>
    <div id="damage-flash"></div>
    <div id="crosshair"></div>

    <div id="hotbar">
        <div class="slot active" id="slot-1">1</div>
        <div class="slot" id="slot-2">2</div>
        <div class="slot" id="slot-3">3</div>
        <div class="slot" id="slot-4">4</div>
        <div class="slot" id="slot-5">5</div>
        <div class="slot" id="slot-6"
            style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><path d=%22M20 80 L80 20 M70 10 L90 30 M80 20 L20 80%22 stroke=%22brown%22 stroke-width=%228%22/><path d=%22M60 10 Q80 -10 100 10 Q110 30 90 40 L60 10%22 fill=%22silver%22 stroke=%22#555%22 stroke-width=%222%22/></svg>');">
            6</div>
        <div class="slot" id="slot-7"
            style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><path d=%22M20 80 L80 20%22 stroke=%22brown%22 stroke-width=%228%22/><path d=%22M50 20 L80 50 L90 30 L60 10 Z%22 fill=%22silver%22 stroke=%22#555%22 stroke-width=%222%22/></svg>');">
            7</div>
    </div>

    <div id="menu">
        <h1>üåç Meu Craft Infinito</h1>
        <button id="btn-play">‚ñ∂Ô∏è Jogar</button>
        <div class="instructions">
            üèÉ‚Äç‚ôÇÔ∏è <b>WASD</b>: Andar | <b>Espa√ßo</b>: Pular<br>
            ‚õèÔ∏è <b>Clique Esq</b>: Quebrar | üß± <b>Clique Dir</b>: Colocar<br>
            üéí <b>1 a 7</b>: Selecionar Bloco/Ferramenta<br>
            üõ†Ô∏è <b>E</b>: Abrir Crafting
        </div>
    </div>

    <div id="crafting-menu">
        <h2>üõ†Ô∏è Mesa de Crafting</h2>
        <p>ü™µ Madeira dispon√≠vel: <span id="craft-madeira">0</span></p>
        <button id="btn-craft-picareta">Criar Picareta (5 Madeira)</button>
        <button id="btn-craft-machado">Criar Machado (5 Madeira)</button>
        <button id="btn-fechar-craft">Fechar (E)</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
        import { SoundManager } from './systems/SoundManager.js';
        import { Ovelha } from './mobs/Ovelha.js';
        import { Vaca } from './mobs/Vaca.js';
        import { Porco } from './mobs/Porco.js';
        import { Cavaleiro } from './mobs/Cavaleiro.js';
        import { MonstroVazio } from './mobs/MonstroVazio.js';

        // üü¢ CONFIGURA√á√ïES B√ÅSICAS
        const cena = new THREE.Scene();
        cena.background = new THREE.Color(0x87CEEB);
        cena.fog = new THREE.Fog(0x87CEEB, 20, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderizador = new THREE.WebGLRenderer({ antialias: false });
        renderizador.setSize(window.innerWidth, window.innerHeight);
        renderizador.shadowMap.enabled = true;
        renderizador.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderizador.domElement);

        const controles = new PointerLockControls(camera, document.body);
        const menu = document.getElementById('menu');
        const craftingMenu = document.getElementById('crafting-menu');

        const soundManager = new SoundManager();
        let inventario = { madeira: 0, picareta: false, machado: false };
        let blocoSelecionado = 1;
        let playerHP = 20;

        function atualizarUI() {
            document.getElementById('qtd-madeira').innerText = inventario.madeira;
            document.getElementById('craft-madeira').innerText = inventario.madeira;
            document.getElementById('btn-craft-picareta').disabled = inventario.madeira < 5 || inventario.picareta;
            document.getElementById('btn-craft-machado').disabled = inventario.madeira < 5 || inventario.machado;
            document.getElementById('player-hp').innerText = playerHP;
        }

        window.addEventListener('playerDamage', (e) => {
            playerHP -= e.detail.amount;
            atualizarUI();
            const flash = document.getElementById('damage-flash');
            if (flash) {
                flash.style.background = 'rgba(255, 0, 0, 0.4)';
                setTimeout(() => flash.style.background = 'rgba(255, 0, 0, 0)', 200);
            }
            soundManager.playSound('hit');
            if (playerHP <= 0) {
                alert("Game Over! Voc√™ foi derrotado pelo Cavaleiro.");
                location.reload();
            }
        });



        document.getElementById('btn-play').addEventListener('click', () => {
            menu.style.display = 'none';
            controles.lock();
            if (soundManager.ctx.state === 'suspended') soundManager.ctx.resume();
        });
        document.getElementById('btn-fechar-craft').addEventListener('click', () => { craftingMenu.style.display = 'none'; controles.lock(); });
        controles.addEventListener('unlock', () => { if (craftingMenu.style.display !== 'flex') menu.style.display = 'flex'; });

        document.getElementById('btn-craft-picareta').addEventListener('click', () => {
            if (inventario.madeira >= 5) { inventario.madeira -= 5; inventario.picareta = true; document.getElementById('slot-6').style.display = 'flex'; atualizarUI(); }
        });
        document.getElementById('btn-craft-machado').addEventListener('click', () => {
            if (inventario.madeira >= 5) { inventario.madeira -= 5; inventario.machado = true; document.getElementById('slot-7').style.display = 'flex'; atualizarUI(); }
        });

        // üí° ILUMINA√á√ÉO
        cena.add(new THREE.AmbientLight(0xffffff, 0.6));
        const luzSol = new THREE.DirectionalLight(0xffffff, 0.8);
        luzSol.position.set(20, 40, 20); luzSol.castShadow = true;
        luzSol.shadow.camera.left = -30; luzSol.shadow.camera.right = 30; luzSol.shadow.camera.top = 30; luzSol.shadow.camera.bottom = -30;
        luzSol.shadow.camera.near = 0.5; luzSol.shadow.camera.far = 100; luzSol.shadow.mapSize.width = 1024; luzSol.shadow.mapSize.height = 1024; luzSol.shadow.bias = -0.001;
        cena.add(luzSol); cena.add(luzSol.target);

        // üé® TEXTURAS DOS BLOCOS & UI
        function gerarTextura(tipo, uiSlot) {
            const canvas = document.createElement('canvas'); canvas.width = 16; canvas.height = 16; const ctx = canvas.getContext('2d');
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    let cor = ''; const ruido = Math.random() * 30 - 15;
                    if (tipo === 'grama_topo') cor = `rgb(${40 + ruido}, ${150 + ruido}, ${40 + ruido})`;
                    else if (tipo === 'grama_lado') cor = y < 4 ? `rgb(${40 + ruido}, ${150 + ruido}, ${40 + ruido})` : `rgb(${100 + ruido}, ${70 + ruido}, ${40 + ruido})`;
                    else if (tipo === 'terra') cor = `rgb(${100 + ruido}, ${70 + ruido}, ${40 + ruido})`;
                    else if (tipo === 'pedra') cor = `rgb(${120 + ruido}, ${120 + ruido}, ${120 + ruido})`;
                    else if (tipo === 'madeira') { const c = (x % 4 === 0 || x % 5 === 0) ? 60 : 90; cor = `rgb(${c + ruido}, ${c / 1.5 + ruido}, ${c / 3 + ruido})`; }
                    else if (tipo === 'folhas') { if (Math.random() > 0.3) cor = `rgb(${20 + ruido}, ${100 + ruido}, ${20 + ruido})`; else { ctx.clearRect(x, y, 1, 1); continue; } }
                    ctx.fillStyle = cor; ctx.fillRect(x, y, 1, 1);
                }
            }
            if (uiSlot) document.getElementById(`slot-${uiSlot}`).style.backgroundImage = `url(${canvas.toDataURL()})`; // üì¶ Coloca no Hotbar!

            const textura = new THREE.CanvasTexture(canvas);
            textura.magFilter = THREE.NearestFilter; textura.minFilter = THREE.NearestFilter; textura.colorSpace = THREE.SRGBColorSpace; return textura;
        }

        const matTerra = new THREE.MeshLambertMaterial({ map: gerarTextura('terra', 2) });
        const matGramaTopo = new THREE.MeshLambertMaterial({ map: gerarTextura('grama_topo') });
        const matGramaLado = new THREE.MeshLambertMaterial({ map: gerarTextura('grama_lado', 1) });

        const materiais = {
            1: [matGramaLado, matGramaLado, matGramaTopo, matTerra, matGramaLado, matGramaLado],
            2: matTerra,
            3: new THREE.MeshLambertMaterial({ map: gerarTextura('pedra', 3) }),
            4: new THREE.MeshLambertMaterial({ map: gerarTextura('madeira', 4) }),
            5: new THREE.MeshLambertMaterial({ map: gerarTextura('folhas', 5), transparent: true, alphaTest: 0.5 })
        };

        // ‚úã SISTEMA DA M√ÉO
        const grupoMao = new THREE.Group();
        grupoMao.position.set(0.6, -0.4, -0.7);
        camera.add(grupoMao); cena.add(camera);

        const matMao = new THREE.MeshLambertMaterial({ color: 0xffccaa });
        const braco = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), matMao);
        braco.position.set(0, -0.3, 0); braco.rotation.x = -Math.PI / 6;
        grupoMao.add(braco);

        let itemSegurado;
        function atualizarMao() {
            if (itemSegurado) grupoMao.remove(itemSegurado);
            if (blocoSelecionado <= 5) {
                itemSegurado = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), materiais[blocoSelecionado]);
                itemSegurado.position.set(0, 0.2, -0.2);
            } else {
                const corMat = blocoSelecionado === 6 ? 0x888888 : 0x8B4513;
                itemSegurado = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.6, 0.4), new THREE.MeshLambertMaterial({ color: corMat }));
                itemSegurado.position.set(0, 0.3, -0.2);
            }
            grupoMao.add(itemSegurado);
        }
        atualizarMao();

        let animandoMao = false; let progressoMao = 0; let bobTimer = 0; // Para animar andando



        let animais = [];
        const geometriaBloco = new THREE.BoxGeometry(1, 1, 1);

        // üî≤ CONTORNO DO BLOCO MIRADO
        const geoContorno = new THREE.EdgesGeometry(new THREE.BoxGeometry(1.005, 1.005, 1.005));
        const matContorno = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
        const contornoBloco = new THREE.LineSegments(geoContorno, matContorno);
        contornoBloco.visible = false; cena.add(contornoBloco);

        // üåç SISTEMA DE CHUNKS INFINITOS
        const mundo = new Map();
        const chunksGerados = new Set();
        const chunksVisuais = new Map();
        const TAMANHO_CHUNK = 16;
        const DISTANCIA_RENDER = 2;
        let chunkAtualX = -999, chunkAtualZ = -999;
        const noise = new ImprovedNoise();

        function obterIdChunk(cx, cz) { return `${cx},${cz}`; }

        function gerarArvore(x, y, z) {
            const altura = Math.floor(Math.random() * 3) + 4;
            for (let i = 0; i < altura; i++) { if (!mundo.has(`${x},${y + i},${z}`)) mundo.set(`${x},${y + i},${z}`, 4); }
            for (let fx = -2; fx <= 2; fx++) {
                for (let fz = -2; fz <= 2; fz++) {
                    for (let fy = altura - 2; fy <= altura + 1; fy++) {
                        const dist = Math.abs(fx) + Math.abs(fy - altura) + Math.abs(fz);
                        if (dist < 4 && !mundo.has(`${x + fx},${y + fy},${z + fz}`)) mundo.set(`${x + fx},${y + fy},${z + fz}`, 5);
                    }
                }
            }
        }

        function criarAnimal(x, y, z, cx, cz) {
            const tipos = ['porco', 'vaca', 'ovelha'];
            const sumChunks = Math.abs(cx) + Math.abs(cz);

            // Cavaleiro a cada 20 chunks
            const isKnight = sumChunks % 20 === 0 && Math.random() < 0.5;
            // Mob 1 (Monstro Vazio) a cada 25 chunks - Spawnamos 2
            const isMob1 = sumChunks > 0 && sumChunks % 25 === 0;

            if (isMob1) {
                animais.push(new MonstroVazio(cena, x, y, z, `${cx},${cz}`));
                animais.push(new MonstroVazio(cena, x + 1.2, y, z + 1.2, `${cx},${cz}`));
                return;
            }

            let animal;
            if (isKnight) {
                animal = new Cavaleiro(cena, x, y, z, `${cx},${cz}`);
            } else {
                const tipo = tipos[Math.floor(Math.random() * tipos.length)];
                if (tipo === 'ovelha') animal = new Ovelha(cena, x, y, z, `${cx},${cz}`);
                else if (tipo === 'vaca') animal = new Vaca(cena, x, y, z, `${cx},${cz}`);
                else animal = new Porco(cena, x, y, z, `${cx},${cz}`);
            }

            animais.push(animal);
        }

        function gerarDadosChunk(cx, cz) {
            const id = obterIdChunk(cx, cz); if (chunksGerados.has(id)) return; chunksGerados.add(id);
            for (let lx = 0; lx < TAMANHO_CHUNK; lx++) {
                for (let lz = 0; lz < TAMANHO_CHUNK; lz++) {
                    const x = cx * TAMANHO_CHUNK + lx; const z = cz * TAMANHO_CHUNK + lz;
                    let alt = Math.floor(noise.noise(x / 30, 0, z / 30) * 8);
                    for (let y = -15; y <= alt; y++) {
                        let buraco = noise.noise(x / 12, y / 12, z / 12);
                        if (y < alt - 2 && buraco > 0.4) continue;
                        let tipo = 3; if (y === alt) tipo = 1; else if (y > alt - 3) tipo = 2;
                        if (!mundo.has(`${x},${y},${z}`)) mundo.set(`${x},${y},${z}`, tipo);
                    }
                    if (Math.random() < 0.02 && mundo.get(`${x},${alt},${z}`) === 1) gerarArvore(x, alt + 1, z);
                }
            }
            if (Math.random() < 0.4) {
                const ax = cx * TAMANHO_CHUNK + Math.floor(Math.random() * TAMANHO_CHUNK);
                const az = cz * TAMANHO_CHUNK + Math.floor(Math.random() * TAMANHO_CHUNK);
                for (let y = 25; y >= -15; y--) { if (mundo.has(`${ax},${y},${az}`)) { criarAnimal(ax, y + 1.62, az, cx, cz); break; } }
            }
        }

        function construirChunkVisual(cx, cz) {
            const id = obterIdChunk(cx, cz); if (chunksVisuais.has(id)) return;
            const grupo = new THREE.Group(); const blocosChunk = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            for (let lx = 0; lx < TAMANHO_CHUNK; lx++) {
                for (let lz = 0; lz < TAMANHO_CHUNK; lz++) {
                    const x = cx * TAMANHO_CHUNK + lx; const z = cz * TAMANHO_CHUNK + lz;
                    for (let y = -15; y < 25; y++) {
                        const tipo = mundo.get(`${x},${y},${z}`);
                        if (tipo) {
                            const exposto = !mundo.has(`${x + 1},${y},${z}`) || !mundo.has(`${x - 1},${y},${z}`) || !mundo.has(`${x},${y + 1},${z}`) || !mundo.has(`${x},${y - 1},${z}`) || !mundo.has(`${x},${y},${z + 1}`) || !mundo.has(`${x},${y},${z - 1}`);
                            if (exposto) blocosChunk[tipo].push(new THREE.Vector3(x, y, z));
                        }
                    }
                }
            }
            for (let tipo in blocosChunk) {
                const pos = blocosChunk[tipo]; if (pos.length === 0) continue;
                const instancedMesh = new THREE.InstancedMesh(geometriaBloco, materiais[tipo], pos.length);
                const matriz = new THREE.Matrix4();
                pos.forEach((p, index) => { matriz.setPosition(p.x, p.y, p.z); instancedMesh.setMatrixAt(index, matriz); });
                instancedMesh.castShadow = true; instancedMesh.receiveShadow = true; grupo.add(instancedMesh);
            }
            cena.add(grupo); chunksVisuais.set(id, grupo);
        }

        function atualizarChunks() {
            const px = Math.floor(camera.position.x / TAMANHO_CHUNK); const pz = Math.floor(camera.position.z / TAMANHO_CHUNK);
            if (px !== chunkAtualX || pz !== chunkAtualZ || chunksVisuais.size === 0) {
                document.getElementById('loading').innerText = "Carregando √°rea..."; chunkAtualX = px; chunkAtualZ = pz;
                for (let cx = px - DISTANCIA_RENDER; cx <= px + DISTANCIA_RENDER; cx++) { for (let cz = pz - DISTANCIA_RENDER; cz <= pz + DISTANCIA_RENDER; cz++) { gerarDadosChunk(cx, cz); } }
                for (let cx = px - DISTANCIA_RENDER; cx <= px + DISTANCIA_RENDER; cx++) { for (let cz = pz - DISTANCIA_RENDER; cz <= pz + DISTANCIA_RENDER; cz++) { construirChunkVisual(cx, cz); } }
                for (const [id, grupo] of chunksVisuais.entries()) {
                    const [cx, cz] = id.split(',').map(Number);
                    if (Math.abs(cx - px) > DISTANCIA_RENDER || Math.abs(cz - pz) > DISTANCIA_RENDER) {
                        cena.remove(grupo); grupo.children.forEach(m => m.dispose()); chunksVisuais.delete(id);
                        animais = animais.filter(a => { if (a.chunkId === id) { cena.remove(a.mesh); return false; } return true; });
                    }
                }
                document.getElementById('loading').innerText = `Chunks ativos: ${chunksVisuais.size}`;
            }
        }

        function recriarChunkVisual(x, z) {
            const cx = Math.floor(x / TAMANHO_CHUNK); const cz = Math.floor(z / TAMANHO_CHUNK); const id = obterIdChunk(cx, cz);
            if (chunksVisuais.has(id)) { const grupo = chunksVisuais.get(id); cena.remove(grupo); grupo.children.forEach(m => m.dispose()); chunksVisuais.delete(id); construirChunkVisual(cx, cz); }
        }

        // üèÉ‚Äç‚ôÇÔ∏è CONTROLES
        camera.position.set(0, 20, 0);
        const teclas = { w: false, a: false, s: false, d: false, space: false };
        let velocidadeY = 0; let noChao = false;

        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyW') teclas.w = true; if (e.code === 'KeyS') teclas.s = true; if (e.code === 'KeyA') teclas.a = true; if (e.code === 'KeyD') teclas.d = true; if (e.code === 'Space') teclas.space = true;

            if (e.code === 'KeyE') {
                if (controles.isLocked) { controles.unlock(); craftingMenu.style.display = 'flex'; atualizarUI(); }
                else { craftingMenu.style.display = 'none'; controles.lock(); }
            }

            if (['1', '2', '3', '4', '5', '6', '7'].includes(e.key)) {
                let numero = parseInt(e.key);
                if (numero === 6 && !inventario.picareta) return;
                if (numero === 7 && !inventario.machado) return;

                blocoSelecionado = numero;
                document.querySelectorAll('.slot').forEach(el => el.classList.remove('active'));
                document.getElementById(`slot-${blocoSelecionado}`).classList.add('active');
                atualizarMao();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW') teclas.w = false; if (e.code === 'KeyS') teclas.s = false; if (e.code === 'KeyA') teclas.a = false; if (e.code === 'KeyD') teclas.d = false; if (e.code === 'Space') teclas.space = false;
        });

        function checarColisao(x, y, z) {
            const w = 0.3; // Um pouco mais largo para no atravessar cantos
            const pos = [
                [x - w, y - 1.62, z - w], [x + w, y - 1.62, z - w], [x - w, y - 1.62, z + w], [x + w, y - 1.62, z + w], // P√©s
                [x - w, y - 0.8, z - w], [x + w, y - 0.8, z - w], [x - w, y - 0.8, z + w], [x + w, y - 0.8, z + w],    // Cintura
                [x - w, y + 0.1, z - w], [x + w, y + 0.1, z - w], [x - w, y + 0.1, z + w], [x + w, y + 0.1, z + w]      // Cabe√ßa
            ];
            return pos.some(p => mundo.has(`${Math.floor(p[0])},${Math.floor(p[1])},${Math.floor(p[2])}`));
        }

        // üì¶ SISTEMA DE DROPS (ITENS NO CH√ÉO)
        let itensDropados = [];
        const geoDrop = new THREE.BoxGeometry(0.25, 0.25, 0.25);
        function droparItem(x, y, z, tipo) {
            const mesh = new THREE.Mesh(geoDrop, materiais[tipo]);
            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            mesh.castShadow = true; cena.add(mesh);
            itensDropados.push({ mesh, tipo, vy: 0.2 }); // D√° um pulinho ao nascer
        }

        // ‚õèÔ∏è INTERA√á√ÉO
        const raycaster = new THREE.Raycaster(); const centroTela = new THREE.Vector2(0, 0);
        let quebrandoBloco = null;
        let tempoQuebrando = 0;
        const TEMPO_PARA_QUEBRAR = 1.3;

        document.addEventListener('mousedown', (e) => {
            if (!controles.isLocked) return;

            if (e.button === 0) { // Tentativa de quebrar
                raycaster.setFromCamera(centroTela, camera);
                const objetos = Array.from(chunksVisuais.values()).flatMap(g => g.children);
                const interseccoes = raycaster.intersectObjects(objetos);

                if (interseccoes.length > 0) {
                    const hit = interseccoes[0];
                    const pt = hit.point; const normal = hit.face.normal;
                    const hitX = Math.round(pt.x - normal.x * 0.5);
                    const hitY = Math.round(pt.y - normal.y * 0.5);
                    const hitZ = Math.round(pt.z - normal.z * 0.5);
                    quebrandoBloco = { x: hitX, y: hitY, z: hitZ };
                    tempoQuebrando = 0;
                } else {
                    // Tenta bater em animal se no acertou bloco
                    const animalIntersects = raycaster.intersectObjects(animais.map(a => a.mesh), true);
                    if (animalIntersects.length > 0) {
                        const meshHit = animalIntersects[0].object;
                        const animal = animais.find(a => {
                            let isChild = false;
                            a.mesh.traverse(child => { if (child === meshHit) isChild = true; });
                            return isChild;
                        });
                        if (animal) animal.sofrerDano(5, soundManager);
                        animandoMao = true; progressoMao = 0;
                    }
                }
            } else if (e.button === 2 && blocoSelecionado <= 5) { // Colocar
                raycaster.setFromCamera(centroTela, camera);
                const objetos = Array.from(chunksVisuais.values()).flatMap(g => g.children);
                const interseccoes = raycaster.intersectObjects(objetos);
                if (interseccoes.length > 0) {
                    const hit = interseccoes[0]; const pt = hit.point; const normal = hit.face.normal;
                    const nx = Math.round(normal.x); const ny = Math.round(normal.y); const nz = Math.round(normal.z);
                    const hitX = Math.round(pt.x - nx * 0.5); const hitY = Math.round(pt.y - ny * 0.5); const hitZ = Math.round(pt.z - nz * 0.5);
                    const placeX = hitX + nx; const placeY = hitY + ny; const placeZ = hitZ + nz;
                    const pX = camera.position.x; const pY = camera.position.y; const pZ = camera.position.z;
                    const dist = Math.sqrt((pX - (placeX + 0.5)) ** 2 + (pZ - (placeZ + 0.5)) ** 2);
                    const noJogador = dist < 0.6 && pY > placeY && pY - 2.0 < placeY;

                    if (!noJogador) {
                        mundo.set(`${placeX},${placeY},${placeZ}`, blocoSelecionado);
                        soundManager.playSound('place');
                        recriarChunkVisual(placeX, placeZ);
                        if (placeX % TAMANHO_CHUNK === 0) recriarChunkVisual(placeX - 1, placeZ); if (placeX % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(placeX + 1, placeZ);
                        if (placeZ % TAMANHO_CHUNK === 0) recriarChunkVisual(placeX, placeZ - 1); if (placeZ % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(placeX, placeZ + 1);
                    }
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                quebrandoBloco = null;
                tempoQuebrando = 0;
                contornoBloco.scale.set(1, 1, 1);
            }
        });

        const relogio = new THREE.Clock();
        function animar() {
            requestAnimationFrame(animar);
            if (controles.isLocked) {
                atualizarChunks(); const delta = relogio.getDelta();

                luzSol.position.set(camera.position.x + 20, camera.position.y + 40, camera.position.z + 20); luzSol.target.position.copy(camera.position);

                raycaster.setFromCamera(centroTela, camera);
                const objs = Array.from(chunksVisuais.values()).flatMap(g => g.children);
                const mira = raycaster.intersectObjects(objs);
                if (mira.length > 0) {
                    const n = mira[0].face.normal;
                    contornoBloco.position.set(Math.round(mira[0].point.x - Math.round(n.x) * 0.5), Math.round(mira[0].point.y - Math.round(n.y) * 0.5), Math.round(mira[0].point.z - Math.round(n.z) * 0.5));
                    contornoBloco.visible = true;
                } else contornoBloco.visible = false;

                const velocidadeAndar = 5 * delta; const posAntiga = camera.position.clone();
                let moveZ = Number(teclas.w) - Number(teclas.s); let moveX = Number(teclas.a) - Number(teclas.d);
                let movendo = moveX !== 0 || moveZ !== 0;

                // ‚úã ANIMA√á√ÉO DA M√ÉO (Bobbing - Andando & Quebrando)
                if (animandoMao) {
                    progressoMao += delta * 15;
                    if (progressoMao > Math.PI) {
                        if (quebrandoBloco) progressoMao = 0; // Loop enquanto quebra
                        else { animandoMao = false; grupoMao.rotation.x = 0; }
                    }
                    else { grupoMao.rotation.x = -Math.sin(progressoMao) * 0.6; }
                }

                if (movendo && noChao) {
                    bobTimer += delta * 12; // Velocidade do balan√ßo
                    grupoMao.position.y = -0.4 + Math.abs(Math.sin(bobTimer)) * 0.05;
                    grupoMao.position.x = 0.6 + Math.sin(bobTimer / 2) * 0.05;
                } else {
                    bobTimer = 0;
                    grupoMao.position.y = THREE.MathUtils.lerp(grupoMao.position.y, -0.4, 0.1);
                    grupoMao.position.x = THREE.MathUtils.lerp(grupoMao.position.x, 0.6, 0.1);
                }

                // üì¶ F√çSICA DOS DROPS & COLETA
                for (let i = itensDropados.length - 1; i >= 0; i--) {
                    let item = itensDropados[i];
                    item.vy -= 1.0 * delta; // Gravidade do item
                    item.mesh.position.y += item.vy;
                    item.mesh.rotation.y += delta; // Fica rodando bonitinho

                    const blockY = Math.floor(item.mesh.position.y - 0.125);
                    if (mundo.has(`${Math.floor(item.mesh.position.x)},${blockY},${Math.floor(item.mesh.position.z)}`)) {
                        item.mesh.position.y = blockY + 1 + 0.125; item.vy = 0; // Bateu no ch√£o
                    }

                    // Checa se o player t√° perto para coletar (Raio de 1.5 blocos)
                    const distToPlayer = camera.position.distanceTo(item.mesh.position);
                    if (distToPlayer < 1.5) {
                        if (item.tipo === 4) { inventario.madeira++; atualizarUI(); soundManager.playSound('collect'); } // Coletou Madeira!
                        cena.remove(item.mesh); item.mesh.geometry.dispose();
                        itensDropados.splice(i, 1);
                    }
                }

                // ‚õèÔ∏è L√ìGICA DE QUEBRA GRADUAL
                if (quebrandoBloco) {
                    tempoQuebrando += delta;
                    animandoMao = true;
                    progressoMao += delta * 5;
                    const scale = 1.0 + Math.sin(tempoQuebrando * 20) * 0.05;
                    contornoBloco.scale.set(scale, scale, scale);

                    if (tempoQuebrando >= TEMPO_PARA_QUEBRAR) {
                        const { x, y, z } = quebrandoBloco;
                        const tipo = mundo.get(`${x},${y},${z}`);
                        if (tipo) {
                            droparItem(x, y, z, tipo);
                            soundManager.playSound('pop');
                            mundo.delete(`${x},${y},${z}`);
                            recriarChunkVisual(x, z);
                            if (x % TAMANHO_CHUNK === 0) recriarChunkVisual(x - 1, z); if (x % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(x + 1, z);
                            if (z % TAMANHO_CHUNK === 0) recriarChunkVisual(x, z - 1); if (z % TAMANHO_CHUNK === TAMANHO_CHUNK - 1) recriarChunkVisual(x, z + 1);
                        }
                        quebrandoBloco = null;
                        tempoQuebrando = 0;
                        contornoBloco.scale.set(1, 1, 1);
                    }
                }

                // üêÑ IA ANIMAIS
                animais.forEach(a => a.update(delta, mundo, camera));

                const direcao = new THREE.Vector3(); camera.getWorldDirection(direcao); direcao.y = 0; direcao.normalize();
                const lado = new THREE.Vector3(); lado.crossVectors(camera.up, direcao).normalize();

                if (movendo) {
                    const moveDir = new THREE.Vector2(moveX, moveZ).normalize();
                    const velX = (lado.x * moveDir.x + direcao.x * moveDir.y) * velocidadeAndar;
                    const velZ = (lado.z * moveDir.x + direcao.z * moveDir.y) * velocidadeAndar;

                    camera.position.x += velX;
                    if (checarColisao(camera.position.x, posAntiga.y, posAntiga.z)) {
                        camera.position.x = posAntiga.x;
                        if (noChao && !checarColisao(camera.position.x + velX, posAntiga.y + 1.1, posAntiga.z)) { velocidadeY = 0.2; camera.position.y += 0.1; noChao = false; }
                    }

                    camera.position.z += velZ;
                    if (checarColisao(camera.position.x, posAntiga.y, camera.position.z)) {
                        camera.position.z = posAntiga.z;
                        if (noChao && !checarColisao(camera.position.x, posAntiga.y + 1.1, posAntiga.z + velZ)) { velocidadeY = 0.2; camera.position.y += 0.1; noChao = false; }
                    }
                }

                if (teclas.space && noChao) { velocidadeY = 0.15; noChao = false; soundManager.playSound('jump'); }
                velocidadeY -= 0.5 * delta; camera.position.y += velocidadeY;

                if (checarColisao(camera.position.x, camera.position.y, camera.position.z)) { camera.position.y = posAntiga.y; velocidadeY = 0; noChao = true; } else noChao = false;
                if (camera.position.y < -30) { camera.position.set(camera.position.x, 20, camera.position.z); velocidadeY = 0; }
            } else relogio.getDelta();

            renderizador.render(cena, camera);
        }

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderizador.setSize(window.innerWidth, window.innerHeight); });
        atualizarChunks(); animar();
    </script>
</body>

</html>